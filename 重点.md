# 重点

## C++

### 多态：意味着调用成员函数时，会根据调用函数的对象的类型来执行不同的函数 （对于同一种指令，针对不同的对象，产生不一样的行为）

- 类型：**静态多态、动态多态**
  - 静态多态：主要有函数重载、运算符重载、模板，在编译的时候就已经确定
  - 动态多态：虚函数机制实现的，在运行期间动态绑定。
  - 如：一个父类类型的指针指向一个子类对象时候，使用父类的指针去调用子类中重写了的父类中的虚函数的时候，会调用子类重写过后的函数，在父类中声明为加了virtual关键字的函数，在子类中重写时候不需要加virtual也是虚函数。
  
- 虚函数的实现：在有虚函数的类中，类的最开始部分是一个虚函数表的指针，这个指针指向一个虚函数表，表中放了虚函数的地址，实际的虚函数在代码段(.text)中。当子类继承了父类的时候也会继承其虚函数表，当子类重写父类中虚函数时候，会将其继承到的虚函数表中的地址替换为重新写的函数地址。使用了虚函数，会增加访问内存开销，降低效率。

### 重载、重写（覆盖）、重定义（隐藏）：

重载：两个函数名相同，但是参数列表不同（个数，类型），返回值类型没有要求，在同一作用域中

- 函数重载为什么不考虑返回值类型
  - 通过将汇编文件重定向到一个文件中进行查看，可以发现函数名映射为一串英文数字，Z数字表示返回值类型、中间为函数名称、最后为参数的类型，就不会存在命名冲突的问题
  - 如果是函数名称相同，参数列表相同，返回值类型不同，如果代码里直接运行函数，并不将返回值存储起来，那么编译器就不知道调用哪个。

重写：子类继承了父类，父类中的函数是虚函数，在子类中重新定义了这个虚函数，这种情况是重写

重定义规则如下：

   a 、如果派生类的函数和基类的函数同名，但是参数不同，此时，不管有无virtual，基类的函数被隐藏。

   b 、如果派生类的函数与基类的函数同名，并且参数也相同，但是基类函数没有vitual关键字，此时，基类的函数被隐藏（如果相同有Virtual就是重写覆盖了）。

### 拷贝构造函数：

### C++11新特性:

C++11 最常用的新特性如下：

auto关键字：编译器可以根据初始值自动推导出类型。但是不能用于函数传参以及数组类型的推导

nullptr关键字：nullptr是一种特殊类型的字面值，它可以被转换成任意其它的指针类型；而NULL一般被宏定义为0，在遇到重载时可能会出现问题。

智能指针：C++11新增了std::shared_ptr、std::weak_ptr等类型的智能指针，用于解决内存管理的问题。

初始化列表：使用初始化列表来对类进行初始化

右值引用：基于右值引用可以实现移动语义和完美转发，消除两个对象交互时不必要的对象拷贝，节省运算存储资源，提高效率

移动语义：对于一个包含指针成员变量的类，由于编译器默认的拷贝构造函数都是浅拷贝，所有我们一般需要通过实现深拷贝的拷贝构造函数，为指针成员分配新的内存并进行内容拷贝，从而避免悬挂指针的问题。（需要自己重新定义一个拷贝构造函数的原因）

## 数据结构和算法：

### 堆和栈的区别：

1）申请方式：

栈由系统自动分配和管理，堆由程序员手动分配和管理。

2）效率：

栈由系统分配，速度快，不会有内存碎片。

堆由程序员分配，速度较慢，可能由于操作不当产生内存碎片。

3）扩展方向

栈从高地址向低地址进行扩展，堆由低地址向高地址进行扩展。

4）程序局部变量是使用的栈空间，new/malloc动态申请的内存是堆空间，函数调用时会进行形参和返回值的压栈出栈，也是用的栈空间。



## 工具：

### valgrind：

编写程序：

```c++
#include <iostream>

using std::cout;
using std::endl;


int main()
{
    int *a = new int[10];
    a[11] = 0;
    cout << a[11] << endl;
    return 0;
}
```

编译该程序：g++ test.cpp -o test -g

执行：

```she
$ valgrind --tool=memcheck --leak-check=yes --show-reachable=yes test
```

输出：

```shell
valgrind --tool=memcheck --leak-check=yes --show-reachable=yes ./test
==8787== Memcheck, a memory error detector
==8787== Copyright (C) 2002-2017, and GNU GPL'd, by Julian Seward et al.
==8787== Using Valgrind-3.13.0 and LibVEX; rerun with -h for copyright info
==8787== Command: ./test
==8787== 
==8787== Invalid write of size 4
==8787==    at 0x1088F8: main (test.cc:17)
==8787==  Address 0x5b7fcac is 4 bytes after a block of size 40 alloc'd
==8787==    at 0x4C3289F: operator new[](unsigned long) (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so)
==8787==    by 0x1088EB: main (test.cc:16)
==8787== 
==8787== Invalid read of size 4
==8787==    at 0x108906: main (test.cc:18)
==8787==  Address 0x5b7fcac is 4 bytes after a block of size 40 alloc'd
==8787==    at 0x4C3289F: operator new[](unsigned long) (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so)
==8787==    by 0x1088EB: main (test.cc:16)
==8787== 
0
==8787== 
==8787== HEAP SUMMARY:
==8787==     in use at exit: 40 bytes in 1 blocks
==8787==   total heap usage: 3 allocs, 2 frees, 73,768 bytes allocated
==8787== 
==8787== 40 bytes in 1 blocks are definitely lost in loss record 1 of 1
==8787==    at 0x4C3289F: operator new[](unsigned long) (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so)
==8787==    by 0x1088EB: main (test.cc:16)
==8787== 
==8787== LEAK SUMMARY:
==8787==    definitely lost: 40 bytes in 1 blocks
==8787==    indirectly lost: 0 bytes in 0 blocks
==8787==      possibly lost: 0 bytes in 0 blocks
==8787==    still reachable: 0 bytes in 0 blocks
==8787==         suppressed: 0 bytes in 0 blocks
==8787== 
==8787== For counts of detected and suppressed errors, rerun with: -v
==8787== ERROR SUMMARY: 3 errors from 3 contexts (suppressed: 0 from 0)

其中：
1.        ==2014== 表示进程号信息，基本没用。
2.        接下来是Memcheck的版权声明信息。
3.        详细的报错信息，如 at 0x1088F8: main (test.cc:17) Address 0x5b7fcac is 4 bytes after a block of size 40 alloc'd
说明test.cc的第17行发生内存访问越界，越界的位移为4。
4.        接着是内存泄漏信息。说明有40byte的内存泄漏
5.        LEAK SUMMARY为内存泄漏信息。
6.        ERROR SUMMARY错误汇总信息。

在LEAK SUMMARY中：
l  definitely lost：表明没有任何指针指向该区域，已经造成了内存泄漏。
l  possibly lost：存在指针指向内存中的某个位置，valgrind认为你有可能是在做一些其他的高级应用（将指针放在申请的内存块中间）
l  still reachable：仍有指针引用该内存块，只是没有释放而已，可以通过设置—show-reachable=yes来报错。
```

## 网络：

### TCP/IP图：

<img src="C:\Users\10690\AppData\Roaming\Typora\typora-user-images\image-20210930113407969.png" alt="image-20210930113407969" style="zoom: 67%;" />



### 三次握手：

- 两次握手为什么不行：
  - 若只有两次握手，**客户端共发出了两个连接请求报文段，其中第一个丢失，第二个到达了服务端**，但是第一个丢失的报文段只是在**某些网络结点长时间滞留了，延误到连接释放以后的某个时间才到达服务端**，此时**服务端误认为客户端又发出一次新的连接请求**，于是就向客户端**发出确认报文段**，**同意建立连接**，此时客户端忽略服务端发来的确认，也不发送数据，**则服务端一致等待客户端发送数据，浪费资源**。

### 四次挥手：

- 三次挥手为什么不行：

  - 关闭连接时，**当服务端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉客户端，"你发的FIN报文我收到了"。只有等到我服务端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四次挥手。**

### 等待2MSL的意义：

- 保证客户端发送的最后一个ACK报文段能够到达服务端。
- 这个ACK报文段有可能丢失，使得处于LAST-ACK状态的B收不到对已发送的FIN+ACK报文段的确认，服务端超时重传FIN+ACK报文段，而客户端能在2MSL时间内收到这个重传的FIN+ACK报文段，**接着客户端重传一次确认**，重新启动2MSL计时器，最后客户端和服务端都进入到CLOSED状态，若客户端在TIME-WAIT状态不等待一段时间，而是**发送完ACK报文段后立即释放连接，则无法收到服务端重传的FIN+ACK报文段，所以不会再发送一次确认报文段，则服务端无法正常进入到CLOSED状态。**
- 防止“已失效的连接请求报文段”出现在本连接中。
-  客户端在发送完最后一个ACK报文段后，再经过2MSL，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失，使下一个新的连接中不会出现这种旧的连接请求报文段。

## 设计模式：

### 单例模式：

- 单例 Singleton 是设计模式的一种，其特点是只提供唯一一个类的实例,具有全局变量的特点，在任何位置都可以通过接口获取到那个唯一实例;
- 具体运用场景如：

1. 设备管理器，系统中可能有多个设备，但是只有一个设备管理器，用于管理设备驱动;
2. 数据池，用来缓存数据的数据结构，需要在一处写，多处读取或者多处写，多处读取;

```c++
#include <iostream>

using std::cout;
using std::endl;

namespace wd
{

class Singleton
{
public:
    static Singleton *getInstance()
    {
        if (nullptr == _pInstance)
        {
            _pInstance = new Singleton();
        }
        return _pInstance;
    }

private:
    Singleton()
    {
        cout << "Singleton()" << endl;
    }

    ~Singleton()
    {
        cout << "~Singleton()" << endl;
    }

private:
    class AutoRelease
    {
    public:
        AutoRelease()
        {
            cout << "AutoRelease()" << endl;
        }
        ~AutoRelease()
        {
            cout << "~AutoRelease()" << endl;
            if (_pInstance)
            {
                delete _pInstance;
                _pInstance = nullptr;
            }
        }

    };

private:
    static Singleton *_pInstance;
    static AutoRelease _ar;
};

//Singleton *Singleton::_pInstance = nullptr;//懒汉模式
Singleton *Singleton::_pInstance = getInstance();//饿汉模式
Singleton::AutoRelease Singleton::_ar;

}// end of namespace wd

int main()
{
    wd::Singleton *ps1 = wd::Singleton::getInstance();
    wd::Singleton *ps2 = wd::Singleton::getInstance();
    return 0;
}
```

### 工厂模式：

- 这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。
  在工厂模式中，我们在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象。

- 简单来说，使用了C++**多态**的特性，将存在**继承**关系的类，通过一个工厂类创建对应的子类（派生类）对象。在项目复杂的情况下，可以便于子类对象的创建。

  工厂模式的实现方式可分别**简单工厂模式、工厂方法模式、抽象工厂模式**，每个实现方式都存在优和劣。

  。。。

## 项目：

### TF-IDF算法：

### Reactor + Threadpool：

常见Reactor模型：

- 单Reactor单线程模型
- 单Reactor多线程模型

<img src="C:\Users\10690\AppData\Roaming\Typora\typora-user-images\image-20210930115117594.png" alt="image-20210930115117594" style="zoom:67%;" />

- 消息处理流程：

1. Reactor对象通过Epoll监控客户端请求事件，收到事件后通过dispatch进行分发。
2. 如果是建立连接请求事件，则由acceptor通过accept处理连接请求，然后创建一个TcpConnection对象处理连接完成后续的各种事件。
3. 如果不是建立连接事件，则Reactor会分发调用连接对应的Handler来响应。
4. TcpConnection只负责响应事件，不做具体业务处理，通过Read读取数据后，会分发给后面的线程池进行业务处理。
5. 线程池会分配独立的线程完成真正的业务处理，然后将响应结果发给TcpConnection进行处理。
6. TcpConnection收到响应结果后通过send将响应结果返回给Client。

- 主从Reactor多线程模型

### mmap零拷贝技术：

<img src="C:\Users\10690\AppData\Roaming\Typora\typora-user-images\image-20210930131049658.png" alt="image-20210930131049658" style="zoom:50%;" />

- 零拷贝主要的任务就是**避免**CPU将数据从一块存储拷贝到另外一块存储，主要就是利用各种零拷贝技术，避免让CPU做大量的数据拷贝任务，减少不必要的拷贝，或者让别的组件来做这一类简单的数据传输任务，让CPU解脱出来专注于别的任务。这样就可以让系统资源的利用更加有效。

- 让数据传输不需要经过user space

减少拷贝次数的一种方法是调用mmap()来代替read调用：

```c++
buf = mmap(diskfd, len);
write(sockfd, buf, len);
```

应用程序调用`mmap()`，磁盘上的数据会通过`DMA`被拷贝的内核缓冲区，接着操作系统会把这段内核缓冲区与应用程序共享，这样就不需要把内核缓冲区的内容往用户空间拷贝。应用程序再调用`write()`,操作系统直接将内核缓冲区的内容拷贝到`socket`缓冲区中，这一切都发生在内核态，最后，`socket`缓冲区再把数据发到网卡去。
 同样的，看图很简单：

<img src="C:\Users\10690\AppData\Roaming\Typora\typora-user-images\image-20210930131338968.png" alt="image-20210930131338968" style="zoom:50%;" />

使用：

```c++
#include <sys/mman.h>

void * mmap (void *addr,//null
             size_t len,//映射的空间大小
             int prot,//内存保护标志
             int flags,//指定映射对象的类型，是否可以被共享
             int fd,//文件描述符
             off_t offset);//被映射的起始地址
```

### Epoll:

