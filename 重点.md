# 重点

## - C++

### 四大特性的区别：【⭐】

- **抽象**（对具体事物的定义过程）

- **封装**（函数放入类或结构中进行操作）

把数据和操作数据的方法捆绑在一起的过程。

例如：把函数放进结构体中进行操作。

```c++
struct Test
{
    int a;
    double b;
    char c;

	void SetData(int xa,double xb,char xc){
    	a = xa;
    	b = xb;
    	c = xc;
	}    
};
```
- **继承**（从既有类产生新类的过程）
  - 派生类不能继承基类的成员函数：
    - 构造函数
    - 析构函数
    - 重载的new / delete运算符
    - 重载的 = 运算符
    - 友元关系
  - 基类中的私有成员都不能在派生类中进行访问
  - 基类中的非私有成员都可以在派生类中进行访问
  - 派生类对象只能访问公有继承基类中的公有成员



- **多态**（对于同一种指令，针对不同的对象，产生不一样的行为）

  - 多态的实现 = 》 虚函数 、纯虚函数

    - 虚函数与纯虚函数的区别：

      - 虚函数是为了**实现动态绑定产生的**，**目的是通过基类类型的指针指向不同对象时，自动调用相应的、和基类同名的函数**。虚函数需要在基类中加上virtual修饰符修饰，因为virtual会被隐式继承，所以子类中相同函数都是虚函数。当一个成员函数被声明为虚函数之后，其派生类中同名函数自动成为虚函数，在派生类中重新定义此函数时要求函数名、返回值类型、参数个数和类型全部与基类函数相同。
      
      - 纯虚函数首先是虚函数，其次它没有函数体，取而代之的是用“=0”。**纯虚函数只是相当于一个接口名，但含有纯虚函数的类不能够实例化**。抽象类一般用于定义一些公有的方法。子类继承抽象类也必须实现其中的纯虚函数才能实例化对象。
      
      - ### 虚函数 vs 纯虚函数，如何选用？
      
        1. 当基类中的某个成员方法，在大多数情形下都应该由子类提供个性化实现，但基类也可以提供缺省备选方案的时候，该方法应该设计为虚函数。
        2. 当基类中的某个成员方法，必须由子类提供个性化实现的时候，应该设计为纯虚函数。

  - 虚函数的底层实现 = 》 虚表指针、虚表（存放虚函数的地址，在代码段中）

    - #### 虚表指针及虚表是在什么时候生成的？【⭐】

      - **虚函数表指针(vptr)**创建时机：

        vptr跟着对象走，所以**对象什么时候创建出来，vptr就什么时候创建出来，也就是运行的时候**。

        所以**这也是为什么构造函数不能为虚函数**。

      - **虚函数表**创建时机：

        **虚函数表创建时机是在编译期间**。编译期间编译器就为**每个类确定好了对应的虚函数表里的内容**。所以**在程序运行时，编译器会把虚函数表的首地址赋值给虚函数表指针，所以，这个虚函数表指针就有值了**。

  - **哪些函数不能设置为虚函数**：

    - 1) #### 构造函数，因为在**创建对象时会调用构造函数**，**构造函数在这时初始化对象的虚表指针**。如果**构造函数是虚函数，那么意味着对象必须要通过虚表指针去调用构造函数，但是在调用构造函数之前，虚表指针还没被赋值，这就出现了矛盾**。【⭐】

      2) 内联函数，**内联函数表示在编译阶段进行函数体的替换操作，而虚函数意味着在运行期间进行类型确定，所以内联函数不能是虚函数**；
  
      3) 静态函数，静态函数不属于对象属于类，**静态成员函数没有this指针**，因此静态函数设置为虚函数没有任何意义。
  
      4) 友元函数，**友元函数不属于类的成员函数，不能被继承**。对于没有继承特性的函数没有虚函数的说法。
  
      5) 普通函数，**普通函数不属于类的成员函数，不具有继承特性**，因此普通函数没有虚函数。



### 多态：意味着调用成员函数时，会根据调用函数的对象类型来执行不同的函数 【⭐】

- 类型：**静态多态、动态多态**
  - **静态多态：主要有函数重载、运算符重载、模板，在编译的时候就已经确定**
  - **动态多态：通过虚函数机制实现的，在运行期间动态绑定。**
  - 如：**一个父类类型的指针指向一个子类对象时候，使用父类的指针去调用子类中重写了的父类中的虚函数的时候，会调用子类重写过后的函数**，在父类中声明为加了virtual关键字的函数，在子类中重写时候不需要加virtual也是虚函数。
  
- ### **虚函数体现多态的原理：**【⭐】

  **当基类定义虚函数的时候，就会在基类对象的存储布局的前面多一个虚函数指针，该指向基类自己的虚表，虚表中存放的是基类的虚函数入口地址；当派生类继承基类的时候，就会把基类的虚函数吸收过来，此时派生类也有虚函数，有虚函数就会有虚函数指针，该指针指向派生类自己的虚表，虚表中存放的是派生类自己的虚函数入口地址，如果此时派生类重写该虚函数，那么存放的是重新定义的虚函数入口地址**；使用了虚函数，会增加访问内存开销，降低效率。

- **虚函数的访问：**

  - 指针访问（动态多态，看基类指针指向的对象）
  - 引用访问（动态多态，看基类指针指向的对象）
  - 对象访问（在编译时就确定，静态多态，通过 . 访问）

### 基类的析构函数为什么一般设置为虚函数？【⭐】

- 由于类的多态性，**基类指针可以指向派生类的对象，如果删除该基类的指针，就会调用该指针指向的派生类析构函数，而派生类的析构函数又自动调用基类的析构函数，这样整个派生类的对象完全被释放。**

  **如果析构函数不被声明成虚函数，则编译器实施静态绑定，在删除基类指针时，只会调用基类的析构函数而不调用派生类析构函数，这样就会造成派生类对象析构不完全，造成内存泄漏。**

  所以将析构函数声明为虚函数是十分必要的。在实现多态时，**当用基类操作派生类，在析构时防止只析构基类而不析构派生类的状况发生，要将基类的析构函数声明为虚函数**。

  

### 重载、重写（覆盖）、重定义（隐藏）：【⭐】

**重载：在同一作用域中，两个函数名相同，但是参数列表不同（个数，类型），返回值类型没有要求**

- 函数重载**为什么不考虑返回值类型**
  - 通过将汇编文件重定向到一个文件中进行查看，可以发现函数名映射为一串英文数字，Z数字表示返回值类型、中间为函数名称、最后为参数的类型，就不会存在命名冲突的问题
  - **如果是函数名称相同，参数列表相同，返回值类型不同，如果代码里直接运行函数，如果不将返回值存储起来，那么编译器就不知道调用哪个。**

**重写：子类继承了父类，父类中的函数是虚函数，在子类中重新定义了这个虚函数，这种情况是重写**

**重定义**规则如下：

   a 、如果**派生类的函数和基类的函数同名，但是参数不同，不管有无virtual，基类的函数被隐藏**。

   b 、如果**派生类的函数与基类的函数同名，并且参数也相同，但是基类函数没有vitual关键字，此时，基类的函数被隐藏**（如果相同有Virtual就是重写覆盖了）。

### 拷贝构造函数：

- **什么时候需要自定义一个拷贝构造函数？**【⭐】
  - 当类对象中的数据成员含有指针时，那么指针指向new空间的申请的内存后需要在析构函数中进行堆空间的释放，这时如果使用默认的拷贝构造函数或拷贝复制函数时，仅仅只是浅拷贝，只是改变对象中指针指向，两个对象在析构时会出现double free；所以需要自定义一个拷贝构造函数或拷贝复制函数来实现深拷贝，将对象中堆空间复制一份，再使用另一个对象的指针指向这片新空间
  - 例子：complex 与 string 两大类
- Big Three：
  - 拷贝构造函数、拷贝复制函数、析构函数

### 模板：

**函数模板要返回一个类型，怎么确定 ？**

显式模板实参
显式模板实参在尖括号中给出，位于函数名之后，实参列表之前。显式模板实参按由左向右的顺序与对应的模板参数匹配。例如

```c++
template<typename T1, typename T2, typename T3>
T1 myFunc(T2, T3);
```

此时，调用myFunc()函数模板的代码为

```c++
myFunc<int, char, float>('1', 0.1F);
```

此时，T1的类型是int，T2的类型是char，T3的类型是Float。

如果可以从调用函数的实参中推断出来T2和T3的类型，则可以从显式模板实参的尾部开始，从右向左依次省略。例如，以上调用函数的代码还可以写成

```c++
myFunc<int>('1', 0.1F);
```

此时，T2和T3的类型可以通过函数的实参进行推断。

### string的底层实现：

- 深拷贝

 ```c++
 #include <iostream>
 #include <string.h>
 
 using std::cout;
 using std::endl;
 
 namespace wd
 {
 class String
 {
 public:
     String(const char* cstr = 0);
     String(const String& str);
     String &operator=(const String& str);
     ~String();
 
 private:
     char* _data;
 };
 
 String::String(const char* cstr)
 {
     if (cstr)
     {
         _data = new char[strlen(cstr) + 1];//cstr的字符串长度 + '\0'
         strcpy(_data, cstr);
     }
     else
     {
         _data = new char[1];//cstr为空时
         *_data = '\0';
     }
 }
 
 String::String(const String& str)
 {
     _data = new char[strlen(str._data) + 1];
     strcpy(_data, str._data);
 }
 
 String& String::operator=(const String& str)
 {
     if (this == &str) return *this;//避免自赋值
 
     delete[] _data;//将原来的内容删除
     _data = new char[strlen(str._data) + 1];
     strcpy(_data, str._data);
 
     return *this;//返回对象本身，可以使用引用返回是因为对象比函数的生命周期大
 }
 
 String::~String()
 {
     delete[] _data;
 }
 }// end of namespace wd
 ```

- 写时复制（Copy On Write）

写时拷贝需要一个**引用计数**，因此要**增加一个存放一个引用计数的位置**，我们将这个位置**放在_str前面的四个字节**，每当**拷贝一次就将引用计数++一次**，进行**修改时先判断一下引用计数是否为1，若为1则直接进行修改**；**否则先重新开辟一块空间，将原有引用计数–，再进行修改**。

- 短字符串优化（SSO）

**一个程序里用到的字符串大部分都很短小**，而在**64位机器上，一个char*指针就占用了8个字**
**节**，所以SSO就出现了，其核心思想是：**发生拷贝时要复制一个指针，对小字符串来说，为啥不直接复制整个字符串呢，说不定还没有复制一个指针的代价大。**  

- **最佳策略**

以上三种方式，都不能解决所有可能遇到的字符串的情况，各有所长，又各有缺陷。综合考虑所有情况
之后，**facebook开源的folly库中**，**实现了一个fbstring**, 它根据字符串的不同长度使用不同的拷贝策略，
最终每个fbstring对象占据的空间大小都是24字节。

1. 很短的（0~22）字符串用SSO，23字节表示字符串（包括'\0'）,1字节表示长度
2. 中等长度的（23~255）字符串用eager copy，8字节字符串指针，8字节size，8字节capacity.
3. 很长的(大于255)字符串用COW, 8字节指针（字符串和引用计数），8字节size，8字节capacity.  



### const 关键字：

- const修饰普通类型的变量：

```c++
const int  a = 7; 
int  b = a; // 正确
a = 8;      // 错误，不能改变
```

-  const 修饰指针变量
   -  **const * （常量指针）与 * const（指针常量）区别：**【⭐】


```c++
const int *p = 8; // 则指针指向的内容 8 不可改变。简称左定值，因为 const 位于 * 号的左边。

int a = 8;
int* const p = &a;
*p = 9; // 正确
int b = 7;
p = &b; // 错误
//对于 const 指针 p 其指向的内存地址不能够被改变，但其内容可以改变。简称，右定向。因为 const 位于 * 号的右边。

int a = 8;
const int * const  p = &a;
// const p 的指向的内容和指向的内存地址都已固定，不可改变。
```

-  const参数传递和函数返回值

```c++
void Cpf(const int a)
{
    cout << a;
    // ++a;  是错误的，a 不能被改变
}
//值传递的 const 修饰传递，一般这种情况不需要 const 修饰，因为函数会自动产生临时变量复制实参值

void Cpf(int *const a)//当 const 参数为指针时，可以防止指针被意外篡改，不可以改变指向
{
    cout << *a << " ";
    *a = 9;
}

void Cmf(const Test& _tt)//自定义类型的参数传递，需要临时对象复制参数，对于临时对象的构造，需要调用构造函数，比较浪费时间，因此我们采取 const 外加引用传递的方法。
{
    cout<<_tt.get_cm();
}
```

-  const修饰类成员函数

```c++
class Test
{
public:
    Test(){}
    Test(int _m):_cm(_m){}
    int get_cm() const //const 修饰类成员函数，其目的是防止成员函数修改被调用对象的值，如果我们不想修改一个调用对象的值，所有的成员函数都应当声明为 const 成员函数。
    {
       return _cm;
    }
 
private:
    int _cm;
};

void Cmf(const Test& _tt)
{
    cout<<_tt.get_cm(); //如果 get_cm() 去掉 const 修饰，则 Cmf 传递的 const _tt 即使没有改变对象的值，编译器也认为函数会改变对象的值，所以我们尽量按照要求将所有的不需要改变对象内容的函数都作为 const 成员函数。
}
```



### new  和 delete 的步骤：

new：

```c++
Complex* pc = new Complex(1, 2);

//转换为
void* mem = operator new(sizeof(Complex));	
//分配内存，调用malloc：分配足够大的未类型化的内存来保存指定类型的空间

pc = static_cast<Complex*>(mem);			//转型

pc->Complex::Complex(1, 2);					
//构造 Complex::Complex(pc, 1, 2), pc=>this，并返回指向新分配并构造好对象的指针
```

delete

```c++
delete pc;

//转换为
Complex::~Complex(pc);	//析构函数：回收对象中数据成员所申请的资源
operator delete(pc);	//释放内存：释放该对象所占用的内存，free(pc)
```



### 类的大小计算（sizeof())

1. 空类编译器会将sizeof（）的值变为1；
2. 类的大小只与非静态成员和虚函数的大小有关，而与其他普通函数成员无关，与构造函数析构函数也无关。
3. 非静态成员计算大小时要记得内存补齐
4. 所有虚函数只占一个指针的大小（即：类中所有虚函数共用一个虚函数指针，指向一个虚函数列表。）



## - C++11:

### 最常用新特性：

- auto关键字：编译器可以根据初始值自动推导出类型。但是不能用于函数传参以及数组类型的推导
- nullptr关键字：nullptr是一种特殊类型的字面值，它可以被转换成任意其它的指针类型；而NULL一般被宏定义为0，在遇到重载时可能会出现问题。
- 【⭐】**智能指针**：C++11新增了shared_ptr、unique_ptr、weak_ptr类型的智能指针，**用于解决内存管理的问题。**
  - 实现：**引用计数**这种计数是为了防止内存泄露而产生的。 基本想法是对于动态分配的对象，进行引用计数，每当增加一次对同一个对象的引用，那么引用对象的引用计数就会增加一次， 每删除一次引用，引用计数就会减一，当一个对象的引用计数减为零时，就自动删除指向的堆内存。
  - **shared_ptr** : 可多个智能指针指向一块内存空间
  - **unique_ptr**: 是一种独占的智能指针，它禁止其他智能指针与其共享同一个对象，从而保证代码的安全；虽然不可复制，但是我们可以利用 `std::move` 将其转移给其他的 `unique_ptr`
  - **weak_ptr**: 弱引用不会引起引用计数增加，没有 `*` 运算符和 `->` 运算符，所以不能够对资源进行操作，它的唯一作用就是用于检查 `std::shared_ptr` 是否存在循环
- 初始化列表：使用初始化列表来对类进行初始化
- 右值引用：基于右值引用可以实现移动语义和完美转发，消除两个对象交互时不必要的对象拷贝，节省运算存储资源，提高效率
- 移动语义：对于一个包含指针成员变量的类，由于编译器默认的拷贝构造函数都是浅拷贝，所有我们一般需要通过实现深拷贝的拷贝构造函数，为指针成员分配新的内存并进行内容拷贝，从而避免悬挂指针的问题。（需要自己重新定义一个拷贝构造函数的原因）
- 【⭐】**Lambda表达式**：(sort的排序规则)

形式：[捕获列表] （参数列表）可选：mutable、throwSpec、->retType  { ... };

```c++
#include <algorithm>
#include <functional>
#include <array>
#include <iostream>
 
int main()
{
    std::array<int, 10> s = {5, 7, 4, 2, 8, 6, 1, 9, 0, 3}; 
 
    // 用默认的 operator< 排序
    std::sort(s.begin(), s.end());
    for (auto a : s) {
        std::cout << a << " ";//0 1 2 3 4 5 6 7 8 9 
    }   
    std::cout << '\n';
 
    // 用标准库比较函数对象排序
    std::sort(s.begin(), s.end(), std::greater<int>());
    for (auto a : s) {
        std::cout << a << " ";//9 8 7 6 5 4 3 2 1 0 
    }   
    std::cout << '\n';
 
    // 用自定义函数对象排序
    struct {
        bool operator()(int a, int b) const
        {   
            return a < b;
        }   
    } customLess;
    std::sort(s.begin(), s.end(), customLess);
    for (auto a : s) {
        std::cout << a << " ";//0 1 2 3 4 5 6 7 8 9 
    }   
    std::cout << '\n';
 
    // 用 lambda 表达式排序
    std::sort(s.begin(), s.end(), [](int a, int b) {
        return b < a;   
    });
    for (auto a : s) {
        std::cout << a << " ";//9 8 7 6 5 4 3 2 1 0
    } 
    std::cout << '\n';
}


//Lambda表达式使用
int main()
{
    int a = 123;
    auto f = [a] { cout << a << endl; }; 
    f(); // 输出：123

    //或通过“函数体”后面的‘()’传入参数
    auto x = [](int a){cout << a << endl;}(123); 
}

//捕获外部变量
//1、值捕获
int main()
{
    int a = 123;
    auto f = [a] { cout << a << endl; }; 
    a = 321;
    f(); // 输出：123
}
//2、引用捕获
int main()
{
    int a = 123;
    auto f = [&a] { cout << a << endl; }; 
    a = 321;
    f(); // 输出：321
}
//3、隐式捕获
int main()
{
    int a = 123;
    auto f = [=] { cout << a << endl; };    // 值捕获
    f(); // 输出：123
    
    int a = 123;
    auto f = [&] { cout << a << endl; };    // 引用捕获
    a = 321;
    f(); // 输出：321
}
捕获形式	说明
[]	不捕获任何外部变量
[变量名, …]	默认以值得形式捕获指定的多个外部变量（用逗号分隔），如果引用捕获，需要显示声明（使用&说明符）
[this]	以值的形式捕获this指针
[=]	以值的形式捕获所有外部变量
[&]	以引用形式捕获所有外部变量
[=, &x]	变量x以引用形式捕获，其余变量以传值形式捕获
[&, x]	变量x以值的形式捕获，其余变量以引用形式捕获
    
//修改捕获变量
int main()
{
    int a = 123;
    auto f = [a]()mutable { cout << ++a; }; // 不会报错
    cout << a << endl; // 输出：123
    f(); // 输出：124
}
```



## - 数据结构和算法（STL）：

### 二叉排序树、平衡二叉树、红黑树：

**二叉排序树：**

一般来讲，**大于根节点的放在根节点的右子树上，小于根节点的放在根节点的左子树上**，如果写程序的话，可以采用递归的方式，而且由于不存在重叠子问题的情况，因此递归的性能已经足够好(不考虑栈溢出的情况)。
**二叉排序树在通常情况下可以达到O(logn)的静态、动态操作的时间复杂度，但是存在一种特殊情况，即输入的数据本身就是有序的，这时二叉排序树退化成链表。**

**平衡二叉排序树（AVL树）：**

**保证了每个节点左子树和右子树的高度差小于等于1，解决了二叉排序树因频繁的插入、删除等动态更新导致的性能退化问题，可以确保静态和动态操作的时间复杂度为O(logn)**

**红黑树：**【⭐】

**不是严格的平衡二叉排序树，而是采用近似平衡的方法，避免了AVL树为每次维持平衡时做的复杂调整操作所带来的耗时，但红黑树插入、删除、查找操作的时间复杂度都是O(logn)， 所以STL中set、map采用红黑树进行插入删除查找操作，且保证元素有序**

### vector 和 list 的底层及区别：【⭐】

- vector：

  **底层**：三个指针：_M_start（头）, _M_finish（最后一个元素的下一个位置）, _M_end_of_storage（已分配内存空间的下一个位置）

  **优点**：和**数组类似**开辟一段连续的空间，并且**支持随机访问**，所以它的**查找效率高其时间复杂度O(1)**。
  **缺点**：由于开辟一段连续的空间，所以**插入删除会需要对数据进行移动比较麻烦，时间复杂度O(n)，另外当空间不足时还需要进行扩容。**

  **扩容机制**：（Linux2倍、Windows1.5倍）

  ​	触发扩容时，如果要插入的数据量比旧容量小，则按两倍扩容；如果要插入的数据量比原来的旧容量还要大，此时将会按照旧容量加要插入的数据量来扩容，保证一次扩容就能容下要插入的数据；即 new_capacity = max ( old_capacity * 2, n + old_capacity )。 

  **迭代器失效**：

  ​	insert时进行了扩容，迭代器会失效，需要重新置位

- list:

  **优点**：**底层实现是循环双链表**，当**对大量数据进行插入删除时，其时间复杂度O(1)**
  **缺点**：底层没有连续的空间，**只能通过指针来访问，所以查找数据需要遍历其时间复杂度O(n)**，没有提供[]操作符的重载。

- 应用：

  如果需要高效的随即访问，而不在乎插入和删除的效率，使用vector

  如果需要高效的插入和删除，而不关心随机访问，则应使用list

### map 和 unordered_map 的底层及区别：【⭐】

- 内部实现机理

  - map： **map内部实现了一个红黑树**，该结构具有**自动排序的功能**，因此map内部的所有元素都是有序的，红黑树的每一个节点都代表着map的一个元素，因此，对于map进行的查找，删除，添加等一系列的操作都相当于是对红黑树进行这样的操作，故红黑树的效率决定了map的效率。
  - unordered_map: **unordered_map内部实现了一个哈希表**，因此其元素的**排列顺序是无序的**

- map

  - 优点：**有序性**，这是map结构最大的优点，其元素的有序性在很多应用中都会简化很多的操作
    红黑树，**内部实现一个红黑书使得map的很多操作在O(logn)的时间复杂度下就可以实现，因此效率非常的高**
  - 缺点：**空间占用率高**，因为map内部实现了红黑树，虽然提高了运行效率，但是因为每一个节点都需要额外保存父节点，孩子节点以及红/黑性质，使得每一个节点都占用大量的空间
    适用处，**对于那些有顺序要求的问题，用map会更高效一些**

- **unordered_map**

  - 优点：因为内部**实现了哈希表，因此其查找速度非常的快O(1)**

  - 缺点：**哈希表的建立比较耗费时间**
    适用处，对于**查找问题，unordered_map会更加高效一些，因此遇到查找问题，常会考虑一下用unordered_map**

  - 解决哈希冲突的方法：

    - 开放定址法：线性探测、二次线性探测
    - 再哈希法
    - 链地址法（开链法）【⭐】
      - hashtable中的bucket所维护的是其自己定义的由hashtable_node数据结构组成的linked-list，而bucket聚合体本身使用vector进行存储。hashtable的迭代器只提供前进操作，不提供后退操作
      - 在hashtable设计bucket的数量上，其内置了28个质数[53, 97, 193,...,429496729]，在创建hashtable时，会根据存入的元素个数选择大于等于元素个数的质数作为hashtable的容量（vector的长度），其中每个bucket所维护的linked-list长度也等于hashtable的容量。如果插入hashtable的元素个数超过了bucket的容量，就要进行重建table操作，即找出下一个质数，创建新的buckets vector，重新计算元素在新hashtable的位置。

    <img src="C:\Users\10690\AppData\Roaming\Typora\typora-user-images\image-20211002110843749.png" alt="image-20211002110843749" style="zoom:67%;" />

### 各种排序算法的复杂度及稳定性，应用场景



### 手撕算法【⭐】

- #### 两个栈实现队列

- #### 最小编辑距离

- #### 反转链表

- #### LRU缓存

- #### 生产者消费者模型（多线程）

- #### 跳台阶

- #### 快排、归并、堆排

- #### 类背包问题



## - 工具：

### valgrind：

编写程序：

```c++
#include <iostream>

using std::cout;
using std::endl;


int main()
{
    int *a = new int[10];
    a[11] = 0;
    cout << a[11] << endl;
    return 0;
}
```

编译该程序：g++ test.cpp -o test -g

执行：

```shell
$ valgrind --tool=memcheck --leak-check=yes --show-reachable=yes ./test
```

输出：

```shell
==8787== Memcheck, a memory error detector
==8787== Copyright (C) 2002-2017, and GNU GPL'd, by Julian Seward et al.
==8787== Using Valgrind-3.13.0 and LibVEX; rerun with -h for copyright info
==8787== Command: ./test
==8787== 
==8787== Invalid write of size 4
==8787==    at 0x1088F8: main (test.cc:17)
==8787==  Address 0x5b7fcac is 4 bytes after a block of size 40 alloc'd
==8787==    at 0x4C3289F: operator new[](unsigned long) (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so)
==8787==    by 0x1088EB: main (test.cc:16)
==8787== 
==8787== Invalid read of size 4
==8787==    at 0x108906: main (test.cc:18)
==8787==  Address 0x5b7fcac is 4 bytes after a block of size 40 alloc'd
==8787==    at 0x4C3289F: operator new[](unsigned long) (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so)
==8787==    by 0x1088EB: main (test.cc:16)
==8787== 
0
==8787== 
==8787== HEAP SUMMARY:
==8787==     in use at exit: 40 bytes in 1 blocks
==8787==   total heap usage: 3 allocs, 2 frees, 73,768 bytes allocated
==8787== 
==8787== 40 bytes in 1 blocks are definitely lost in loss record 1 of 1
==8787==    at 0x4C3289F: operator new[](unsigned long) (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so)
==8787==    by 0x1088EB: main (test.cc:16)
==8787== 
==8787== LEAK SUMMARY:
==8787==    definitely lost: 40 bytes in 1 blocks
==8787==    indirectly lost: 0 bytes in 0 blocks
==8787==      possibly lost: 0 bytes in 0 blocks
==8787==    still reachable: 0 bytes in 0 blocks
==8787==         suppressed: 0 bytes in 0 blocks
==8787== 
==8787== For counts of detected and suppressed errors, rerun with: -v
==8787== ERROR SUMMARY: 3 errors from 3 contexts (suppressed: 0 from 0)

其中：
1.        ==2014== 表示进程号信息，基本没用。
2.        接下来是Memcheck的版权声明信息。
3.        详细的报错信息，如 at 0x1088F8: main (test.cc:17) Address 0x5b7fcac is 4 bytes after a block of size 40 alloc'd
说明test.cc的第17行发生内存访问越界，越界的位移为4。
4.        接着是内存泄漏信息。说明有40byte的内存泄漏
5.        LEAK SUMMARY为内存泄漏信息。
6.        ERROR SUMMARY错误汇总信息。

在LEAK SUMMARY中：
l  definitely lost：表明没有任何指针指向该区域，已经造成了内存泄漏。
l  possibly lost：存在指针指向内存中的某个位置，valgrind认为你有可能是在做一些其他的高级应用（将指针放在申请的内存块中间）
l  still reachable：仍有指针引用该内存块，只是没有释放而已，可以通过设置—show-reachable=yes来报错。
```



## - 数据库（只会命令）

### MySQL

### Redis





## - 网络：

### TCP/IP图：

<img src="C:\Users\10690\AppData\Roaming\Typora\typora-user-images\image-20210930113407969.png" alt="image-20210930113407969" style="zoom: 67%;" />

### **TCP与UDP的区别：**

- **TCP是面向连接的**。（**一对一**）

- TCP**提供可靠交付的服务**。

  通过TCP连接传送的数据，无差错、不丢失、不重复、并且按序到达；

  - **确认和重传**：接收方收到报文就会确认，发送方发送一段时间后没有收到确认就会重传。
  - **数据校验**：TCP报文头有校验和，用于校验报文是否损坏。
  - **数据合理分片和排序**：tcp会按最大传输单元(MTU)合理分片，接收方会缓存未按序到达的数据，重新排序后交给应用层。而UDP：IP数据报大于1500字节，大于MTU。这个时候发送方的IP层就需要分片，把数据报分成若干片，是的每一片都小于MTU。而接收方IP层则需要进行数据报的重组。由于UDP的特性，某一片数据丢失时，接收方便无法重组数据报，导致丢弃整个UDP数据报。
  - **流量控制**：当接收方来不及处理发送方的数据，能通过**滑动窗口**，提示发送方降低发送的速率，防止包丢失。【双方传输速率问题】
  - **拥塞控制**：当网络拥塞时，通过**拥塞窗口**，减少数据的发送，防止包丢失。（四大算法）【双方传输通畅问题】

- TCP**提供全双工通信**。

- **面向字节流**。“面向字节流”的含义是：虽然应用程序和TCP的交互是一次一个数据块（大小不等），但TCP把应用程序交下来的数据仅仅看成是一连串的无结构的字节流。（使用了私有协议，将每次发送的包前4字节保存后方数据的长度，后方保存的是数据）



### 三次握手：【⭐】

- 过程：

  - **初始状态**：客户端处于 `closed(关闭)`状态，服务器处于 `listen(监听)` 状态。
  - **第一次握手**：客户端发送请求报文 `SYN = 1`和初始化序列号`seq = x`发送给服务端，发送完之后客户端处于`SYN_Send`状态。
  - **第二次握手**：服务端收到 `SYN=1` 请求报文之后，如果同意连接，发送`SYN(服务端) = 1`、 `seq = y`和确认序列号`ack = x + 1` 以及确认号`ACK = 1`报文作为应答，服务器为`SYN_Receive`状态。
  - **第三次握手**： 客户端接收到服务端的 `SYN + ACK`之后，然后发送 `ack = y + 1`和数据包的序列号 `seq = x + 1`以及确认号`ACK = 1`确认包作为应答，客户端转为`established`状态。

- 序列号时怎么产生的？（seq = x）

   ISN(Initial Sequence Number)是固定的吗？（怎样产生）

   当一端为建立连接而发送它的SYN时，它为连接选择一个初始序号。ISN随时间而变化，因此每个连接都将具有不同的ISN。如果 ISN 是固定的，攻击者很容易猜出后续的确认号，因此 ISN 是动态生成的。

- 两次握手为什么不行：
  - 若只有两次握手，**客户端共发出了两个连接请求报文段，其中第一个丢失，第二个到达了服务端**，但是第一个丢失的报文段只是在**某些网络结点长时间滞留了，延误到连接释放以后的某个时间才到达服务端**，此时**服务端误认为客户端又发出一次新的连接请求**，于是就向客户端**发出确认报文段**，**同意建立连接**，此时客户端忽略服务端发来的确认，也不发送数据，**则服务端一致等待客户端发送数据，浪费资源**。

### 四次挥手：【⭐】

- 过程：

  - 第一次挥手：客户端发出FIN=1，序号seq=u，并停止再发送数据，主动关闭TCP连接，进入FIN_WAIT1状态，等待服务端的确认。
  - 第二次挥手： 服务端收到连接释放报文段后即发出 ACK=1，ack=u+1，seq=v，服务端进入CLOSE_WAIT状态，此时的TCP处于半关闭状态，客户端到服务端的连接释放。客户端收到服务端的确认后，进入FIN_WAIT2（终止等待2）状态，等待服务端发出的连接释放报文段。
  - 第三次挥手：服务端没有要向客户端发出的数据，服务端发出FIN=1，ACK=1，seq=w，ack=u+1，服务端进入LAST_ACK状态，等待客户端的确认。
  - 第四次挥手：客户端收到服务端的连接释放报文段后，发出ACK=1，seq=u+1，ack=w+1，客户端进入TIME_WAIT（时间等待）状态。此时TCP未释放掉，需要经过时间等待计时器设置的时间2MSL后，客户端才进入CLOSED状态。

  收到一个FIN只意味着在这一方向上没有数据流动。**客户端执行主动关闭并进入TIME_WAIT是正常的，服务端通常执行被动关闭，不会进入TIME_WAIT状态。**在socket编程中，任何一方执行close()操作即可产生挥手操作。

- 三次挥手为什么不行：

  - 关闭连接时，**当服务端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉客户端，"你发的FIN报文我收到了"。只有等到我服务端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四次挥手。**

### 等待2MSL的意义：

- 保证客户端发送的最后一个ACK报文段能够到达服务端。
- 这个ACK报文段有可能丢失，使得处于LAST-ACK状态的B收不到对已发送的FIN+ACK报文段的确认，服务端超时重传FIN+ACK报文段，而客户端能在2MSL时间内收到这个重传的FIN+ACK报文段，**接着客户端重传一次确认**，重新启动2MSL计时器，最后客户端和服务端都进入到CLOSED状态，若客户端在TIME-WAIT状态不等待一段时间，而是**发送完ACK报文段后立即释放连接，则无法收到服务端重传的FIN+ACK报文段，所以不会再发送一次确认报文段，则服务端无法正常进入到CLOSED状态。**
- 防止“已失效的连接请求报文段”出现在本连接中。
-  客户端在发送完最后一个ACK报文段后，再经过2MSL，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失，使下一个新的连接中不会出现这种旧的连接请求报文段。

## - Linux（操作系统）：

### 堆和栈的区别：

​	1）申请方式：

​	栈由系统自动分配和管理，堆由程序员手动分配和管理。

​	2）效率：

​	栈由系统分配，速度快，不会有内存碎片。

​	堆由程序员分配，速度较慢，可能由于操作不当产生内存碎片。

​	3）扩展方向

​	栈从高地址向低地址进行扩展，堆由低地址向高地址进行扩展。

​	4）程序局部变量是使用的栈空间，new/malloc动态申请的内存是堆空间，函数调用时会进行形参和返回值的压栈出栈，也是用的栈空间。

### 进程的三种状态：

- 运行、就绪、阻塞

### 进程间的通信方式：【⭐】

1. **管道**（pipe）【亲缘】, 有名管道（FIFO）【可在非亲缘间通信，是一种特殊的文件类型】

2. **信号**（signal）【硬件中断软件模拟，利用Signal函数捕获、改变信号的行为】

   信号是一种比较复杂的通信方式,用于通知接收进程某个事件已经发生

3. 进程间的高级通信方式：**共享内存、信号量、消息队列**

   - **共享内存：**（应用mmap）
     
     - 共享内存就是**映射一段能被其他进程所访问的内存,这段共享内存由一个进程创建,但多个进程都可以访问**.共享内存是最快的IPC(进程间通信)方式,它是针对其它进程间通信方式运行效率低而专门设计的.它往往与其他通信机制,如信号量,配合使用,来实现进程间的同步与通信.
     
     - 创建后会一直存在，不会随进程结束而消失，直到命令删除或重启
     
     - 删除使用标记删除的方法
     
     - **为什么说共享内存是最快的一种IPC方式呢？**【⭐】
     
       <img src="C:\Users\10690\AppData\Roaming\Typora\typora-user-images\image-20211002143923514.png" alt="image-20211002143923514" style="zoom:50%;" />
     
       我们可以看出，**使用管道(FIFO/消息队列)从一个文件传输信息到另外一个文件需要复制4次。**一是，**服务器端将信息从相应的文件复制到server临时缓冲区中**；二是，**从临时缓冲区中复制到管道（FIFO/消息队列）**；三是，**客户端将信息从管道（FIFO/消息队列）复制到client端的缓冲区中**；四是，**从client临时缓冲区将信息复制到输出文件中**。
       <img src="C:\Users\10690\AppData\Roaming\Typora\typora-user-images\image-20211002144014262.png" alt="image-20211002144014262" style="zoom:50%;" />
     
       我们可以看出，**共享内存的消息复制只有两次**。一是，**从输入文件到共享内存；二是，从共享内存到输出文件。这样就很大程度上提高了数据存取的效率。**
     
     - **共享内存的应用：mmap（零拷贝技术）：**【⭐】
     
       mmap()系统调用使得进程之间通过映射同一个普通文件实现共享内存。普通文件被映射到进程地址空间后，进程可以像访问普通内存一样对文件进行访问，不必再调用read,write等操作。
   - 信号量：
     - 用于进程间的同步与互斥（PV操作）
     
     - **信号量	与（条件变量+互斥锁）的区别**：
     
       **有了互斥锁和条件变量还提供信号量的原因是**：“本标准提供**信号量的而主要目的是提供一种进程间同步的方式**；这些进程可能共享也可能不共享内存区。**互斥锁和条件变量是作为线程间的同步机制**说明的；这些线程总是共享(某个)内存区。这两者都是已广泛使用了多年的同步方式。每组原语都特别适合于特定的问题”。**尽管信号量的意图在于进程间同步，互斥锁和条件变量的意图在于线程间同步，但是信号量也可用于线程间，互斥锁和条件变量也可用于进程间。应当根据实际的情况进行决定**。**信号量最有用的场景是用以指明可用资源的数量。**
   - 消息队列：
     - 消息队列提供了一种从一个进程向另一个进程发送一个数据块的方法

4. 套接字（**socket**)【网络编程】

   socket，即套接字是一种通信机制，凭借这种机制，**客户/服务器（即要进行通信的进程）系统的开发工作既可以在本地单机上进行，也可以跨网络进行**。也就是说它可以让不在同一台计算机但通过网络连接计算机上的进程进行通信。也因为这样，套接字明确地将客户端和服务器区分开来。
   
   套接字的特性由3个属性确定，它们分别是：域、类型和协议。



### 进程与线程的区别：

**进程：进程时资源分配的基本单位，拥有自己独立的数据段、代码段、堆栈段、所以CPU切换进程的时候需要保存上下文，开销大**

**线程：CPU调度的基本单位，一个进程里面至少拥有一个线程，线程只拥有少量的栈空间，并且全部线程共享该地址空间，不利于资源的管理和保护**



### 多线程的使用(创建，退出，等待，同步互斥)：【⭐】

- 进程与线程的区别

  进程是资源分配的基本单位，拥有自己独立的资源，独立的数据段、代码段、堆栈段，所以CPU切换进程的时候，需要保存上下文，开销比较大

  线程是CPU调度的基本单位，一个进程里面至少拥有一个线程，如果在一个进程里面创建多个线程，那么这些线程共享该地址空间。线程只拥有少量的栈空间

- **创建**：pthread_create（**线程id（pthread_t th）**，线程属性（默认填NULL），**线程处理函数，线程处理函数的参数**（没有为NULL，**可以使用struct包裹传入多个参数**））

- **退出**：pthread_exit（NULL）

- **等待**：pthread_join（等待退出的线程id，接受子线程的退出值）

- **查看线程的命令**：

  ```shell
  $ ps -elLf
  ```
  
- **线程间的同步互斥**：【⭐】
  
  - 使用pthread_mutex_t 创建一把互斥锁；
  - pthread_mutex_init为刚刚创建的锁初始化，默认NULL为普通锁
  - 使用pthread_mutex_lock对准备访问的临界资源上锁，访问后使用pthread_mutex_unlock解锁
  - 当锁为处于unlock状态时才可以用pthread_mutex_destory销毁锁
  - 使用pthread_cond_t 创建一个条件变量（登记表）
  - pthread_cond_init 为刚刚创建的条件变量初始化，默认NULL的属性
  - 使用pthread_cond_wait (&条件变量、&互斥锁) 来实现不满足条件时解锁 “登记”，无条件等待直到被激活；而timewait可以设置等待一段时间，不满足就返回
  - 生产者线程生产后任务队列不为空，就通过pthread_cond_singnal激活一个等待的消费者线程，broadcast激活全部等待的线程
  - 某个消费者线程被激活后上锁，访问临界区，完成后解锁，任务队列不为满再通知生产者线程生产
  - 只有当条件变量没有被使用时，才能使用pthread_cond_destory销毁
  
  
  
  - **程序在获取了临界资源后异常退出，临界资源一直处于加锁状态，其他进程/线程申请锁程序未正常处理就会导致阻塞，甚至死锁等待，怎么处理？**
  
    设置锁的过期时间？
  
  
  
  - 死锁产生的条件
    1、互斥属性：即每次只能有一个线程占用资源。
    2、请求与保持：即已经申请到锁资源的线程可以继续申请。在这种情况下，一个线程也可以产生死锁情况，即抱着锁找锁。
    3、不可剥夺：线程已经得到所资源，在没有自己主动释放之前，不能被强行剥夺。
    4、循环等待：多个线程形成环路等待，每个线程都在等待相邻线程的锁资源。-
  - 死锁的避免：
    1、既然死锁的产生是由于使用了锁，那么在能不使用锁的情况下就尽量不使用，如果有多种方案都能实现，那么尽量不选用带锁的这种方案
    2、尽量避免同时获得多把锁，如果有必要，就要保证获得锁的顺序相同

- **可能出现假共享**

**伪共享发生在不同处理器上的线程对变量的修改依赖于相同的缓存行**

现在 CPU 都是**多核**的，由于 L1/L2 Cache 是多个核⼼各⾃独有的，**如果多个CPU访问的不同内存变量被装载到了同一个cache line 中，则从程序逻辑层上讲，并没有共享变量，但实际上在cache line 上他们是共享访问的，这个就是典型的伪共享。** **多个CPU对共享内存的访问安全通过缓存一致性来保证。**

- **项目中使用互斥锁与条件变量进行多线程对任务队列的访问获取任务**，使用Buffer类封装queue<Task>，并**依赖**mutex，condition类进行同步互斥【⭐】

### GDB调试：

- 一般调试：gdb调试core文件

```
1.core文件
当程序运行过程中出现Segmentation fault (core dumped)错误时，程序停止运行，并产生core文件。core文件是程序运行状态的内存映象。使用gdb调试core文件，可以帮助我们快速定位程序出现段错误的位置。当然，可执行程序编译时应加上-g编译选项，生成调试信息。

当程序访问的内存超出了系统给定的内存空间，就会产生Segmentation fault (core dumped)，因此，段错误产生的情况主要有： 
 （1）访问不存在的内存地址； 
 （2）访问系统保护的内存地址； 
 （3）数组访问越界等。

core dumped又叫核心转储, 当程序运行过程中发生异常, 程序异常退出时, 由操作系统把程序当前的内存状况存储在一个core文件中, 叫core dumped。

2.具体步骤一： 
 （-1）先编译 + -g
 （0）使用ulimit -c unlimited，则表示core文件的大小不受限制。
 （1）启动gdb，进入core文件，命令格式：gdb [exec file] [core file]。 
  用法示例：gdb ./test test.core。
 （2）在进入gdb后，查找段错误位置：where或者bt 
 可以定位到源程序中具体文件的具体位置，出现了段错误。
```

- 调试多线程

```
1、运行可执行文件./a.out
2、ps -aL|grep a.out 查看主线程id(4400)
3、pstree -p 4400 查看线程情况
4、(sudo) gdb attach 4400 进入调试
5、info threads 查看线程信息
6、thread 2 / thread 3 切换线程
7、b 函数名 设置断点
8、info b 查看断点
9、n 下一步
10、cont 继续运行
11、thread apply all bt 查看所有线程的栈情况
12、set scheduler-locking off/on 不锁定任何线程，也就是所有线程都执行/只有当前被调试程序会执行
```



## - 设计模式：

### 单例模式：

- 单例 Singleton 是设计模式的一种，其特点是只提供唯一一个类的实例,具有全局变量的特点，在任何位置都可以通过接口获取到那个唯一实例;
- 具体运用场景如：

【⭐】自己项目中的Configuration类（运行服务端时进行文件配置类《文件名，文件路径》，用于文件的检索），**此类设置为单例模式，不能进行拷贝构造，赋值构造，整个服务器只有一个对象，其他类通过getInstance静态成员函数获取对象，调用对象来进行文件的输入检索**（其他类依赖此类，**其他类 -------> 配置类，A use B**）

1. 设备管理器，系统中可能有多个设备，但是只有一个设备管理器，用于管理设备驱动;
2. 数据池，用来缓存数据的数据结构，需要在一处写，多处读取或者多处写，多处读取;

```c++
class Singleton
{
public:
    static Singleton *getInstance()
    {
        if (nullptr == _pInstance)
        {
            _pInstance = new Singleton();
        }
        return _pInstance;
    }

private:
    Singleton()
    {
        cout << "Singleton()" << endl;
    }

    ~Singleton()
    {
        cout << "~Singleton()" << endl;
    }

private:
    class AutoRelease
    {
    public:
        AutoRelease()
        {
            cout << "AutoRelease()" << endl;
        }
        ~AutoRelease()
        {
            cout << "~AutoRelease()" << endl;
            if (_pInstance)
            {
                delete _pInstance;
                _pInstance = nullptr;
            }
        }

    };

private:
    static Singleton *_pInstance;
    static AutoRelease _ar;
};

//Singleton *Singleton::_pInstance = nullptr;//懒汉模式
Singleton *Singleton::_pInstance = getInstance();//饿汉模式
Singleton::AutoRelease Singleton::_ar;

}// end of namespace wd

int main()
{
    Singleton *ps1 = wd::Singleton::getInstance();
    Singleton *ps2 = wd::Singleton::getInstance();
    return 0;
}

========================================================
#ifndef __SINGLETON_HPP__
#define __SINGLETON_HPP__

#include "Noncopyable.hpp" 
#include <pthread.h>
#include <stdlib.h>

namespace wd
{

//线程安全的Singleton
template<typename T>
class Singleton
: Noncopyable//不可被拷贝构造和复制构造
{
public:
    static T& instance()
    {
        pthread_once(&_ponce, &Singleton::init);//只执行一次
//本函数使用初值为PTHREAD_ONCE_INIT的once_control变量保证init_routine()函数在多线程执行序列中仅执行一次。使用该函数保证了多线程安全。
        return *_value;
    }

private:
    Singleton();
    ~Singleton();
    //init若不被声明为静态类型，则第一个参数为this指针，便不满足pthread_once传入无参函数的要求
    static void init()
    {
        _value = new T();
        atexit(destroy);//单例模式的自动释放
    }
    static void destroy()
    {
        if (_value)
        {
            delete _value;
            _value = NULL;
        }
    }

private;
    static pthread_once_t _ponce;
    static T* _value;
};

template<typename T>
pthread_once_t Singleton<T>::_ponce = PTHREAD_ONCE_INIT;//用于识别是否执行函数

template<typename T>
T* Singleton<T>::_value = NULL;//懒汉模式

// template<typename T>
// T* Singleton<T>::_value = Singleton::instance();//饿汉模式

}// end of namespace wd

#endif //SINGLETON_HPP
```

### 工厂模式：

- 这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。
  在工厂模式中，我们在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象。

- 简单来说，使用了C++**多态**的特性，将存在**继承**关系的类，通过一个工厂类创建对应的子类（派生类）对象。在项目复杂的情况下，可以便于子类对象的创建。

  工厂模式的实现方式可分别**简单工厂模式、工厂方法模式、抽象工厂模式。**

  。。。
  
- 简单工厂：

<img src="C:\Users\10690\AppData\Roaming\Typora\typora-user-images\image-20211007152946265.png" alt="image-20211007152946265" style="zoom:50%;" />

- 工厂模式：

<img src="C:\Users\10690\AppData\Roaming\Typora\typora-user-images\image-20211007153100836.png" alt="image-20211007153100836" style="zoom:50%;" />

- 抽象工厂：

<img src="C:\Users\10690\AppData\Roaming\Typora\typora-user-images\image-20211007153148969.png" alt="image-20211007153148969" style="zoom: 67%;" />

### 观察者模式：

<img src="C:\Users\10690\AppData\Roaming\Typora\typora-user-images\image-20211007153810085.png" alt="image-20211007153810085" style="zoom:67%;" />

## - 项目：

### 项目介绍：

#### **自我介绍**：

- 面试官您好，本人名叫叶炜鸿，来自广东，熟悉在Linux下使用C++后端开发，熟悉多线程编程、网络编程，了解IO复用机制，Reactor高性能网络模式。在实习阶段参与了两个项目的开发，分别为图书搜索推荐系统和文件管理系统

**图书搜索推荐项目 **是在Linux下使用C++开发，分为**离线和在线**模块；

**离线部分有词典文件及词典索引文件的建立、网页库、网页偏移库及倒排索引库的建立，用于提高搜索效率，此部分为本人主要负责的模块；**

（词库大小：几百个xml文件提取的词库）

在线部分的**服务端采用Reactor加线程池的服务器模型**，分离计算和IO线程，提高工作效率，使用json进行双端的数据传输；

**当客户端输入查询词后，服务端会根据查询词检索词典库，使用最小编辑距离算法计算候选词与查询词的相似度，返回相似度最高的候选词，实现关键字的推荐，通过TF-IDF算法计算每个查询词的权重，组成向量，然后继续检索倒排索引库，在包含所有查询词的网页中获取词的权重，组成该网页的向量，最后使用余弦相似度算法对网页进行向量夹角的计算，将网页筛选排序，返回相关性最高的若干书籍信息给用户**

（检索一次花费时间：有缓存的话是一两秒，没有的话就6、7秒）

（流程：分词 -》检索词典库 -》返回推荐词 -》计算查询词的权重，组成向量 -》找到包含所有查询词的网页，从倒排索引表中获取该网页中所有的w'，组成向量 -》使用余弦相似度算法计算向量的cosΘ，越大说明越相似 -》返回若干相关性最高的网页信息，**并将此查询词与对应的网页信息保存到缓存中**）

**在线整体框架**：

![image-20211007170002172](C:\Users\10690\AppData\Roaming\Typora\typora-user-images\image-20211007170002172.png)

还有：InetAddres（端口地址）、Socket（listenfd）、SocketIO（read、write）、Acceptor（connfd）、TcpConnection（双方通信）、EpollPoller（epoll）



**文件管理项目**是在Linux下使用C++开发，采用单Reactor多线程的服务器模型，**类似百度网盘**，具有多用户同时登录注册，上传下载文件的功能；

**本人主要负责登陆注册模块中的用户密码加密、虚拟文件表的设计、文件秒传、断点续传的功能；**

此外还有**mmap的零拷贝技术**为**大文件传输进行优化**，回收站等功能；

**密码加密功能**：使用crypt函数，参数1为用户密码，参数2为盐值【使用函数随机生成】

- 服务器先传输 salt 值（从用户表中查找）给客户端， 客户端 crypt 加密后， 传输密码密文给服务器， 服务器进行匹配后， 判断是否成功（登录）

- 服务器判断用户名，生成新的salt值保存到用户表，发送给客户端，客户端输入密码与salt值加密后，传输密文给服务器保存（注册）

**断点续传功能**：该功能支持从文件上次中断的地方开始传送数据， 而并非是从文件开头传送。

- 举例：进行 gets hello.avi 时候， 首先**判断本地是否存在 hello.avi**
  如果存在， 则通过 **stat 函数获取本地文件 hello.avi 的大小**， 然后传递给服务器的是gets hello.avi 1000
  如果不存在， 则直接进行下载即可。
- **文件传输前进行文件MD5的校验，是否与断点后的文件内容保持一致，再进行续传**，以防文件打开错误

**文件秒传：**将文件使用MD5加密，加密后使用MD5码作为文件的名称，将其写入到虚拟文件表中，实现文件 秒传

- **计算MD5的时间会不会比较久？**

  **大文件采用分片计算**

**使用TCP传输，为什么？**

​	TCP的特点，使用私有协议，

​	**数据出错需要校验怎么办：TCP如何保证数据的正确性，保证数据内容不会出错**

​		**首部校验**，这个校验机制能够确保数据传输不会出错吗？

​		**答案是不能**，因为这种校验方式是累加和，也就是将一系列的数字求和后取末位。假如在传输的过程中有前后两个16比特位的数据前后颠倒了，那么**校验和的计算结果**和**颠倒之前是一样的**，那么接收端肯定无法检查出这是错误的数据。

​		解决：最简单的就是使用MD5校验，在发送数据前将数据**使用MD5加密**，并**将MD5摘要一起发送**，接收端接**收数据后将数据再次用MD5加密，如果得到的摘要和收到的摘要一致说明数据正确**。**但也不一定绝对安全**

**面试时询问和 ftp 有什么区别**， 个性化功能回答
1、 多级权限管理
2、 某一级主管可以分享给自己的下属小组查看文件
3、 文件分为可下载和在线阅读， 读后即焚等  

4、**不会限速**





### TF-IDF算法：

- 计算词频TF（某个词在文章中出现的次数），计算逆文档频率IDF（该词对该文章的重要系数），使用总文章数除以包含该词的文章数+1，再取以2为底的对数，最后计算该词语权重w
- 建立倒排索引表：
  - 每篇文章中包含多个词语的权重，需要对文章中的所有词进行归一化处理
  - 计算w‘，用该词在该文章中权重除以根号下该文章中所有词的权重和
  - 最后使用unoredred_map保存<词，该词所在的文章，w'>



### IO模型（阻塞、非阻塞、同步、异步）

举个你去饭堂吃饭的例⼦，你好⽐应⽤程序，饭堂好⽐操作系统。

- 阻塞 I/O 好⽐，你去饭堂吃饭，但是饭堂的菜还没做好，然后你就⼀直在那⾥等啊等，等了好⻓⼀段时间
  终于等到饭堂阿姨把菜端了出来（数据准备的过程），但是你还得继续等阿姨把菜（内核空间）打到你的
  饭盒⾥（⽤户空间），经历完这两个过程，你才可以离开。

- ⾮阻塞 I/O 好⽐，你去了饭堂，问阿姨菜做好了没有，阿姨告诉你没，你就离开了，过⼏⼗分钟，你⼜来
  饭堂问阿姨，阿姨说做好了，于是阿姨帮你把菜打到你的饭盒⾥，这个过程你是得等待的。

  **上面都是同步**

- 异步 I/O 好⽐，你让饭堂阿姨将菜做好并把菜打到饭盒⾥后，把饭盒送到你⾯前，整个过程你都不需要任
  何等待。  

  - Reactor与Proactor的区别：
    - Reactor 是⾮阻塞同步⽹络模式，感知的是**就绪可读写**事件。  
    - Proactor 是异步⽹络模式， 感知的是**已完成的读写**事件。  
    - 因此， Reactor 可以理解为「来了事件操作系统通知应⽤进程，让应⽤进程来处理」 ，⽽ Proactor 可以理解为「来了事件操作系统来处理，处理完再通知应⽤进程」 。  

  ![image-20211007162736470](C:\Users\10690\AppData\Roaming\Typora\typora-user-images\image-20211007162736470.png)

  - 可惜的是，**在 Linux 下的异步 I/O 是不完善的**，aio 系列函数是由 POSIX 定义的异步操作接⼝，不是真正的操作系统级别⽀持的，⽽是在⽤户空间模拟出来的异步，并且仅仅⽀持基于本地⽂件的 aio 异步操作，⽹络编程中的 socket 是不⽀持的，**这也使得基于 Linux 的⾼性能⽹络程序都是使⽤ Reactor ⽅案**。
  - **⽽ Windows ⾥实现了⼀套完整的⽀持 socket 的异步编程接⼝，这套接⼝就是 IOCP ，是由操作系统级**
    **别实现的异步 I/O，真正意义上异步 I/O，因此在 Windows ⾥实现⾼性能⽹络程序可以使⽤效率更⾼的**
    **Proactor ⽅案。**  



### Reactor + Threadpool：【⭐】【并发服务器（网络）模型】

常见Reactor模型：

**Reactor 模式也叫 Dispatcher 模式**，我觉得这个名字更贴合该模式的含义，**即 I/O 多路复用监听事件，收到事件后，根据事件类型分配（Dispatch）给某个进程 / 线程。**  

**Reactor 是⾮阻塞同步⽹络模式**  

- 单Reactor单线程模型

<img src="C:\Users\10690\AppData\Roaming\Typora\typora-user-images\image-20211007160223397.png" alt="image-20211007160223397" style="zoom: 67%;" />

但是，这种⽅案存在 **2 个缺点**：
	第⼀个缺点，因为只有⼀个进程， **⽆法充分利⽤ 多核 CPU 的性能**；
	第⼆个缺点， **Handler 对象在业务处理时，整个进程是⽆法处理其他连接的事件的， 如果业务处理耗时⽐较⻓，那么就造成响应的延迟；**
所以，单 Reactor 单进程的⽅案**不适⽤计算机密集型的场景，只适⽤于业务处理⾮常快速的场景**。  

**应用场景**：Redis 是由 C 语⾔实现的，它采⽤的正是「单 Reactor 单进程」的⽅案，**因为 Redis 业务处理主要在内存中完成，操作的速度是很快的，性能瓶颈不在 CPU 上，所以 Redis 对于命令的处理是单进程的⽅案**。  

- 单Reactor多线程模型
  - **线程数量**：对于IO密集型，线程数量一般等于CPU核心数；对于计算密集型，线程数量一般等于核心数+1

<img src="C:\Users\10690\AppData\Roaming\Typora\typora-user-images\image-20210930115117594.png" alt="image-20210930115117594" style="zoom:67%;" />

<img src="C:\Users\10690\AppData\Roaming\Typora\typora-user-images\image-20211007160300659.png" alt="image-20211007160300659" style="zoom:67%;" />

- **消息处理流程**：

  - Reactor 对象通过 select （IO 多路复⽤接⼝） 监听事件，收到事件后通过 dispatch 进⾏分发，具体
    分发给 Acceptor 对象还是 Handler 对象，还要看收到的事件类型；
  - 如果是连接建⽴的事件，则交由 Acceptor 对象进⾏处理， Acceptor 对象会通过 accept ⽅法 获取连
    接，并创建⼀个 Handler 对象来处理后续的响应事件；
  - 如果不是连接建⽴事件， 则交由当前连接对应的 Handler 对象来进⾏响应；  
  - Handler 对象不再负责业务处理，只负责数据的接收和发送， Handler 对象通过 read 读取到数据后，
    会将数据发给⼦线程⾥的 Processor 对象进⾏业务处理；
  - ⼦线程⾥的 Processor 对象就进⾏业务处理，处理完后，将结果发给主线程中的 Handler 对象，接着
    由 Handler 通过 send ⽅法将响应结果发送给 client；  

  **单 Reator 多线程的方案优势在于能够充分利⽤多核 CPU 的性能**  ，但因为⼀个 Reactor 对象承担所有事件的监听和响应，⽽且只在主线程中运⾏，**在⾯对瞬间⾼并发的场景时，容易成为性能的瓶颈的地⽅**。  

- 主从Reactor多线程模型

<img src="C:\Users\10690\AppData\Roaming\Typora\typora-user-images\image-20211007161233330.png" alt="image-20211007161233330" style="zoom:67%;" />

具体差异表现**在主进程中仅仅⽤来初始化 socket，并没有创建 mainReactor 来 accept 连接，⽽是由⼦进**
**程的 Reactor 来 accept 连接，通过锁来控制⼀次只有⼀个⼦进程进⾏ accept（防⽌出现惊群现象），⼦**
**进程 accept 新连接后就放到⾃⼰的 Reactor 进⾏处理，不会再分配给其他⼦进程。**  

应用场景：⼤名鼎鼎的**两个开源软件 Netty 和 Memcache 都采⽤了「多 Reactor 多线程」的⽅案**。
**采⽤了「多 Reactor 多进程」⽅案的开源软件是 Nginx，不过⽅案与标准的多 Reactor 多进程有些差异**。  



### mmap零拷贝技术：【⭐】【共享内存的应用】

<img src="C:\Users\10690\AppData\Roaming\Typora\typora-user-images\image-20210930131049658.png" alt="image-20210930131049658" style="zoom:50%;" />

- 零拷贝主要的任务就是**避免**CPU将数据从一块存储拷贝到另外一块存储，主要就是利用各种零拷贝技术，避免让CPU做大量的数据拷贝任务，减少不必要的拷贝，或者让别的组件来做这一类简单的数据传输任务，让CPU解脱出来专注于别的任务。这样就可以让系统资源的利用更加有效。

- 让数据传输不需要经过user space

减少拷贝次数的一种方法是调用mmap()来代替read调用：

```c++
buf = mmap(diskfd, len);
write(sockfd, buf, len);
```

**应用程序调用`mmap()`，磁盘上的数据会通过`DMA`被拷贝的内核缓冲区，接着操作系统会把这段内核缓冲区与应用程序共享（映射），这样就不需要把内核缓冲区的内容往用户空间拷贝。应用程序再调用`write()`,操作系统直接将内核缓冲区的内容拷贝到`socket`缓冲区中，这一切都发生在内核态，最后，`socket`缓冲区再把数据发到网卡去。**
 同样的，看图很简单：

<img src="C:\Users\10690\AppData\Roaming\Typora\typora-user-images\image-20210930131338968.png" alt="image-20210930131338968" style="zoom:50%;" />

使用：

```c++
#include <sys/mman.h>

void * mmap (void *addr,//null
             size_t len,//映射的空间大小
             int prot,//内存保护标志
             int flags,//指定映射对象的类型，是否可以被共享
             int fd,//文件描述符
             off_t offset);//被映射的起始地址
```

### Epoll:【⭐】【并发的关键，IO多路复用】

- epoll是Linux下多路复用IO接口select/poll的增强版本，**它能显著减少程序在大量并发连接中只有少量活跃的情况下的系统CPU利用率**

- epoll **在内核⾥使⽤红⿊树来跟踪进程所有待检测的⽂件描述符**，把需要监控的 socket 通过
  epoll_ctl() 函数加⼊内核中的红⿊树⾥，红⿊树是个⾼效的数据结构，增删查⼀般时间复杂度是
  O(logn) ，通过对这棵⿊红树进⾏操作，这样就不需要像 select/poll 每次操作时都传⼊整个 socket 集
  合，只需要传⼊⼀个待检测的 socket，**减少了内核和⽤户空间⼤量的数据拷⻉和内存分配**。

- epoll **使⽤事件驱动的机制**，内核⾥维护了⼀个链表来记录就绪事件，当某个 socket 有事件发⽣
  时，**通过回调函数内核会将其加⼊到这个就绪事件列表中，当⽤户调⽤ epoll_wait() 函数时，只会返回有**
  **事件发⽣的⽂件描述符的个数，不需要像 select/poll 那样轮询扫描整个 socket 集合，⼤⼤提⾼了检测的效**
  **率**。  

- epoll ⽀持两种事件触发模式，分别是**边缘触发**（edge-triggered， ET） 和**⽔平触发**（level-triggered，
  LT） 。  

  如果使⽤⽔平触发模式，当内核通知⽂件描述符可读写时，接下来还可以继续去检测它的状态，看它是否
  依然可读或可写。所以在收到通知后，没必要⼀次执⾏尽可能多的读写操作。

  如果使⽤边缘触发模式， I/O 事件发⽣时只会通知⼀次，⽽且我们不知道到底能读写多少数据，所以在收到
  通知后应尽可能地读写数据，以免错失读写的机会。因此，我们会循环从⽂件描述符读写数据，那么如果
  ⽂件描述符是阻塞的，没有数据可读写时，进程会阻塞在读写函数那⾥，程序就没办法继续往下执⾏。所
  以， 边缘触发模式⼀般和⾮阻塞 I/O 搭配使⽤，程序会⼀直执⾏ I/O 操作，直到系统调⽤（如 read 和
  write ）返回错误，错误类型为 EAGAIN 或 EWOULDBLOCK 。  
  
- **项目中使用epoll进行事件的分发（dispatch），分别监听listenfd，connfd，eventfd；（主线程中）**

  - listenfd就绪，处理连接connection回调函数
  - connfd就绪，处理任务，处理message回调函数，（read）接受消息，使用function与bind封装成Task，加入到任务队列中，交给线程处理
  - eventfd就绪，**说明线程处理任务完成，将处理后的任务交给主线程发送**（将处理后任务放入pending的vector中，weakup（使用write置值）激活eventfd），（使用read读取置零）send发送消息给各自客户端

### Git的使用：只会简单的命令，交给组长完成



## - 公司：

### 做什么的：

软件开发、信息技术咨询、计算机系统服务

