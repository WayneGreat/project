# 操作系统

### 1、编译过程

![image-20210915191751325](C:\Users\10690\AppData\Roaming\Typora\typora-user-images\image-20210915191751325.png)

- 预处理阶段：处理以 # 开头的预处理命令；
- 编译阶段：翻译成汇编文件；
- 汇编阶段：将汇编文件翻译成可重定位目标文件；
- 链接阶段：将可重定位目标文件和 printf.o 等单独预编译好的目标文件进行合并，得到最终的可执行目标文件。

### 2、进程、线程是什么？区别是什么？了解协程吗

|          | 进程                                                         | 线程                                               | 协程                                                         |
| :------- | :----------------------------------------------------------- | :------------------------------------------------- | ------------------------------------------------------------ |
| 定义     | **资源分配和拥有的基本单位**                                 | **程序执行的基本单位**                             | **用户态的轻量级线程，线程内部调度的基本单位**               |
| 切换情况 | 进程CPU环境(栈、寄存器、页表和文件句柄等)的保存以及新调度的进程CPU环境的设置 | 保存和设置程序计数器、少量寄存器和栈的内容         | 先将寄存器上下文和栈保存，等切换回来的时候再进行恢复         |
| 切换者   | 操作系统                                                     | 操作系统                                           | 用户                                                         |
| 切换过程 | 用户态->内核态->用户态                                       | 用户态->内核态->用户态                             | 用户态(没有陷入内核)                                         |
| 调用栈   | 内核栈                                                       | 内核栈                                             | 用户栈                                                       |
| 拥有资源 | CPU资源、内存资源、文件资源和句柄等                          | 程序计数器、寄存器、栈和状态字                     | 拥有自己的寄存器上下文和栈                                   |
| 并发性   | 不同进程之间切换实现并发，各自占有CPU实现并行                | 一个进程内部的多个线程并发执行                     | 同一时间只能执行一个协程，而其他协程处于休眠状态，适合对任务进行分时处理 |
| 系统开销 | 切换虚拟地址空间，切换内核栈和硬件上下文，CPU高速缓存失效、页表切换，开销很大 | 切换时只需保存和设置少量寄存器内容，因此开销很小   | 直接操作栈则基本没有内核切换的开销，可以不加锁的访问全局变量，所以上下文的切换非常快 |
| 通信方面 | 进程间通信需要借助操作系统                                   | 线程间可以直接读写进程数据段(如全局变量)来进行通信 | 共享内存、消息队列                                           |

**进程：进程时资源分配的基本单位，拥有自己独立的数据段、代码段、堆栈段、所以CPU切换进程的时候需要保存上下文，开销大**

**线程：CPU调度的基本单位，一个进程里面至少拥有一个线程，线程只拥有少量的栈空间，并且全部线程共享该地址空间，不利于资源的管理和保护**

- 调度：线程是调度的基本单位（PC，状态码，通用寄存器，线程栈及栈指针）；进程是拥有资源的基本单位（打开文件，堆，静态区，代码段等）。
- 并发性：一个进程内多个线程可以并发（最好和CPU核数相等）；多个进程可以并发。
- 拥有资源：线程不拥有系统资源，但一个进程的多个线程可以共享隶属进程的资源；进程是拥有资源的独立单位。
- 系统开销：线程创建销毁只需要处理PC值，状态码，通用寄存器值，线程栈及栈指针即可；进程创建和销毁需要重新分配及销毁task_struct结构。

### 3、协程是轻量级的线程，轻量级表现在哪里？

？？？拥有自己的寄存器上下文和栈

### 4、进程间通信的方式有哪些（IPC方式）？（Linux）

- **管道**：
  - 无名管道（内存文件）：**管道是一种半双工的通信方式**，数据只能**单向**流动，而且只**能在具有亲缘关系的进程之间使用**。进程的亲缘关系通常是指**父子进程**关系。
  - 有名管道（FIFO文件，借助文件系统）：有名管道也是**半双工的通信方式**，但是**允许在没有亲缘关系的进程之间使用**，管道是先进先出的通信方式。
- **共享内存**：共享内存就是**映射一段能被其他进程所访问的内存**，这段**共享内存由一个进程创建，但多个进程都可以访问**。**共享内存是最快的IPC方式**，它是针对其他进程间通信方式运行效率低而专门设计的。它**往往与信号量，配合使用来实现进程间的同步和通信**。
- **消息队列**：消息队列是有消息的**链表**，存放在内核中并由消息队列标识符标识。消息队列**克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点**。
- **套接字**：**适用于不同机器间进程通信，在本地也可作为两个进程通信的方式**。
- **信号**：用于通**知接收进程某个事件已经发生**，比如**按下ctrl + C就是信号**。
- **信号量**：**信号量是一个计数器**，可以用来**控制多个进程对共享资源的访问**。它常作为一种**锁机制**，实现**进程、线程的对临界区的同步及互斥访问。**

### 5、[IO多路复用有哪几种方式？区别](https://www.cnblogs.com/dunitian/p/10099343.html)【⭐】epoll多路复用

- 常用的IO多路复用方式有`select`、`poll`和`epoll`
- 区别：
  - select监控的文件描述符有限制，默认是1024个，与底层实现是位图有关；poll（使用链表的方式存储fd）与epoll（红黑树+双向链表）没有最大文件描述符限制
  - select与poll一致，是轮询+遍历集合来检查就绪文件描述符；epoll只需要检查就绪链表，不需要遍历所有的文件描述符
  - select每次都会修改监控的集合，所以每次都需要把监听的文件描述符重新加入到集合中；epoll把需要监听的文件描述符加入到红黑树时，一次注册后永久生效，并且内核会给每一个加入到红黑树上的文件描述符注册一个回调函数（作用：当文件描述符就绪时执行回调函数）-> 将其加入到双向链表中
- 效率问题：
  - epoll不一定比select效率高，一般认为在并发量低，socket的文件描述符都比较活跃的情况下，select的效率会更高
- 代码实现：
  - 使用循环（islooping标志位进行控制），一直再监听文件描述符
  - 接受对应的文件描述符，处理相应的事务

### 6、同步/异步IO

- 同步：阻塞IO、非阻塞IO、IO多路复用、信号驱动 IO（用户进程主动读取数据）

- 异步：异步IO（用户进程只需要关注IO操作完成的通知，并不主动读取数据）

### 7、信号量（同步）和锁（互斥）

- 进程及线程的通信方法
  - **信号量(**semaphore)：信号量主要作为**进程间以及同进程不同线程之间的同步手段**；

- 线程的通信方法
  - 锁机制（线程锁）：**互斥锁、条件变量**、读写锁、自旋锁

  - **互斥锁：一次只能一个线程拥有互斥锁，其他线程只有等待**
  - 条件变量：条件变量通过允许线程阻塞和等待另一个线程发送信号的方法弥补了互斥锁的不足，他常和互斥锁一起使用，以免出现竞态条件。当条件不满足时，线程往往解开相应的互斥锁并阻塞线程然后等待条件发生变化。**一旦其他的某个线程改变了条件变量，他将通知相应的条件变量唤醒一个或多个正被此条件变量阻塞的线程**。总的来说**互斥锁是线程间互斥的机制，条件变量则是同步机制。**

- **信号量：可用于进程同步，也可用于线程同步；互斥锁 + 条件变量：只能用于线程同步**

### 8、线程安全【⭐】

- 定义：一个函数能够安全地同时被多个线程调用而得到正确的结果

- 实现：同步（条件变量）与互斥（互斥锁）

- 互斥锁：任何时刻，互斥保证有且只有一个执行流进入到临界区对临界资源进行操作，通常对临街资源起保护作用。
- 条件变量：线程在对临界资源访问之前，先判断是否能够进行操作；若可以进行操作则线程直接操作；否则线程在条件变量提供的队列上排队，并将互斥锁解锁，进入睡眠状态；当该线程促使条件满足，然后唤醒在等待对列上的该线程，将临界资源上锁并访问

### 9、内存泄漏的后果？如何监测？解决方法？

- **内存泄露**
  - 一般我们常说的内存泄漏是指**堆内存的泄漏**。**由于疏忽或错误造成了程序未能释放掉不再使用的内存的情况，失去了对该段内存的控制**

- **后果**
  - **只发生一次小的内存泄漏可能不被注意，但泄漏大量内存的程序将会出现各种证照：性能下降到内存逐渐用完，导致另一个程序失败；**

- **检测工具**
  - Linux下可以使用**Valgrind工具**
    - [使用方式](https://www.cnblogs.com/AndyStudy/p/6409287.html)
  - Windows下可以使用**CRT库**

- **解决方法**
  - 智能指针。

### 10、进程同步的四种方法？

1、**临界区**（Critical Section）:通过**对多线程的串行化来访问公共资源或一段代码，速度快，适合控制数据访问**。

优点：保证在某一时刻只有一个线程能访问数据的简便办法

缺点：虽然临界区同步速度很快，但却**只能用来同步本进程内的线程，而不可用来同步多个进程中的线程**。

 

2、**互斥量**（Mutex）:为**协调共同对一个共享资源的单独访问**而设计的。

互斥量跟临界区很相似，比临界区复杂，**互斥对象只有一个**，**只有拥有互斥对象的线程才具有访问资源的权限**。

优点：使用互斥不仅仅能够在同一应用程序不同线程中实现资源的安全共享，而且可以在不同应用程序的线程之间实现对资源的安全共享。

缺点：①互斥量是可以命名的，也就是说它可以跨越进程使用，所以创建互斥量需要的资源更多，所以如果只为了在进程内部是用的话使用临界区会带来速度上的优势并能够减少资源占用量。因为互斥量是跨进程的互斥量一旦被创建，就可以通过名字打开它。

②通过互斥量可以指定资源被独占的方式使用，但如果有下面一种情况通过互斥量就无法处理，比如现在一位用户购买了一份三个并发访问许可的数据库系统，可以根据用户购买的访问许可数量来决定有多少个线程/进程能同时进行数据库操作，这时候如果利用互斥量就没有办法完成这个要求，信号量对象可以说是一种资源计数器。

 

3、**信号量**（Semaphore）:**为控制一个具有有限数量用户资源而设计**。它允许多个线程在同一时刻访问同一资源，但是需要限制在同一时刻访问此资源的最大线程数目。互斥量是信号量的一种特殊情况，当信号量的最大资源数=1就是互斥量了。

优点：适用于对Socket（套接字）程序中线程的同步。（例如，网络上的HTTP服务器要对同一时间内访问同一页面的用户数加以限制，只有不大于设定的最大用户数目的线程能够进行访问，而其他的访问企图则被挂起，只有在有用户退出对此页面的访问后才有可能进入。）

缺点：①信号量机制必须有公共内存，不能用于分布式操作系统，这是它最大的弱点；

②信号量机制功能强大，但使用时对信号量的操作分散， 而且难以控制，读写和维护都很困难，加重了程序员的编码负担；

③核心操作P-V分散在各用户程序的代码中，不易控制和管理，一旦错误，后果严重，且不易发现和纠正。

 

4、**事件（Event）**: **用来通知线程有一些事件已发生，从而启动后继任务的开始**。

优点：事件对象通过通知操作的方式来保持线程的同步，并且可以实现不同进程中的线程同步操作。

**总结**：

①**临界区不是内核对象，只能用于进程内部的线程同步，是用户方式的同步。互斥、信号量是内核对象可以用于不同进程之间的线程同步（跨进程同步）**。
②互斥其实是信号量的一种特殊形式。**互斥可以保证在某一时刻只有一个线程可以拥有临界资源**。**信号量可以保证在某一时刻有指定数目的线程可以拥有临界资源。**

### 11、守护进程、僵尸进程和孤儿进程

（1）守护进程：

- 指在**后台运行**的，**没有控制终端与之相连的进程**。它独立于控制终端，周期性地执行某种任务。Linux的大多数服务器就是用守护进程的方式实现的，如web服务器进程http等

（2）孤儿进程

- **一个父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程**。孤儿进程将被init进程(进程号为1)所收养，并由init进程对它们完成状态收集工作。

（3）僵尸进程

- **如果子进程先退出，父进程还没退出，那么子进程必须等到父进程捕获到了子进程的退出状态才真正结束，否则这个时候子进程就成为僵尸进程。**

- 设置**僵尸进程的目**的是维护子进程的信息，以便父进程在以后某个时候获取。这些信息至少包括进程ID，进程的终止状态，以及该进程使用的CPU时间，所以当终止子进程的父进程调用wait或waitpid时就可以得到这些信息。如果一个进程终止，而该进程有子进程处于僵尸状态，那么它的所有僵尸子进程的父进程ID将被重置为1（init进程）。继承这些子进程的init进程将清理它们（也就是说init进程将wait它们，从而去除它们的僵尸状态）。

### 12、多进程和多线程的区别是什么？换句话说，什么时候该用多线程，什么时候该用多进程？

- 频繁修改：需要**频繁创建和销毁**的优先使用**多线程**
- 计算量：需要大量计算的优先使用**多线程** 因为**需要消耗大量CPU资源且切换频繁**，所以多线程好一点
- 相关性：任务间**相关性比较强**的用**多线程**，**相关性比较弱**的用**多进程**。因为线程之间的数据共享和同步比较简单。
- 多分布：可能要扩展到**多机分布**的用**多进程**，**多核分布**的用**多线程**。

但是实际中更常见的是进程加线程的结合方式，并不是非此即彼的。

### 13、什么是线程池？为什么要用线程池？【⭐】

1、降低资源的消耗。降低线程创建和销毁的资源消耗；
2、提高响应速度：线程的创建时间为T1，执行时间T2,销毁时间T3，免去T1和T3的时间
3、提高线程的可管理性。

