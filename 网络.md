# 网络

# 【⭐】**画出来**

![image-20210915212420712](C:\Users\10690\AppData\Roaming\Typora\typora-user-images\image-20210915212420712.png)

### 1、TCP、UDP的区别【⭐】

- **UDP是无连接的**；UDP使用**尽最大努力交付**，即不保证可靠交付，因此主机不需要维持复杂的链接状态（这里面有许多参数）；UDP是**面向报文**的；UDP**没有拥塞控制**，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如IP电话，实时视频会议等）；UDP**支持一对一、一对多、多对一和多对多**的交互通信；UDP的**首部开销小**，只有8个字节，比TCP的20个字节的首部要短。

- **TCP是面向连接的**。（就好像打电话一样，通话前需要先拨号建立连接，通话结束后要挂机释放连接）；每一条TCP连接只能有两个端点，每一条TCP连接只能是点对点的（**一对一**）；TCP**提供可靠交付的服务**。通过TCP连接传送的数据，无差错、不丢失、不重复、并且按序到达；TCP**提供全双工通信**。TCP允许通信双方的应用进程在任何时候都能发送数据。TCP连接的两端都设有发送缓存和接收缓存，用来临时存放双方通信的数据；**面向字节流**。TCP中的“流”（stream）指的是流入进程或从进程流出的字节序列。“面向字节流”的含义是：虽然应用程序和TCP的交互是一次一个数据块（大小不等），但TCP把应用程序交下来的数据仅仅看成是一连串的无结构的字节流。
  - **TCP可靠传输手段**
    - **确认和重传**：接收方收到报文就会确认，发送方发送一段时间后没有收到确认就会重传。
    - **数据校验**：TCP报文头有校验和，用于校验报文是否损坏。
    - **数据合理分片和排序**：tcp会按最大传输单元(MTU)合理分片，接收方会缓存未按序到达的数据，重新排序后交给应用层。而UDP：IP数据报大于1500字节，大于MTU。这个时候发送方的IP层就需要分片，把数据报分成若干片，是的每一片都小于MTU。而接收方IP层则需要进行数据报的重组。由于UDP的特性，某一片数据丢失时，接收方便无法重组数据报，导致丢弃整个UDP数据报。
    - **流量控制**：当接收方来不及处理发送方的数据，能通过**滑动窗口**，提示发送方降低发送的速率，防止包丢失。【双方传输速率问题】
    - **拥塞控制**：当网络拥塞时，通过**拥塞窗口**，减少数据的发送，防止包丢失。（四大算法）【双方传输通畅问题】

### 2、TCP三次握手建立连接的过程？三次握手过程通信双方各自的状态？

<img src="C:\Users\10690\AppData\Roaming\Typora\typora-user-images\image-20210915211321502.png" alt="image-20210915211321502" style="zoom:67%;" />

刚开始客户端处于 Closed 的状态，服务端处于 Listen 状态，进行三次握手：

- 第一次握手：客户端给服务端发一个 SYN 报文，并指明客户端的初始化序列号 ISN(c)。此时客户端处于 `SYN_SEND` 状态。

  首部的同步位SYN=1，初始序号seq=x，SYN=1的报文段不能携带数据，但要消耗掉一个序号。

- 第二次握手：服务器收到客户端的 SYN 报文之后，会以自己的 SYN 报文作为应答，并且也是指定了自己的初始化序列号 ISN(s)。同时会把客户端的 ISN + 1 作为ACK 的值，表示自己已经收到了客户端的 SYN，此时服务器处于 `SYN_RCVD` 的状态。

  在确认报文段中SYN=1，ACK=1，确认号ack=x+1，初始序号seq=y。

- 第三次握手：客户端收到 SYN 报文之后，会发送一个 ACK 报文，当然，也是一样把服务器的 ISN + 1 作为 ACK 的值，表示已经收到了服务端的 SYN 报文，此时客户端处于 `ESTABLISHED` 状态。服务器收到 ACK 报文之后，也处于 `ESTABLISHED` 状态，此时，双方已建立起了连接。

  确认报文段ACK=1，确认号ack=y+1，序号seq=x+1（初始为seq=x，第二个报文段所以要+1），ACK报文段可以携带数据，不携带数据则不消耗序号。

发送第一个SYN的一端将执行主动打开（active open），接收这个SYN并发回下一个SYN的另一端执行被动打开（passive open）。

**在socket编程中，客户端执行connect()时，将触发三次握手。**

### 3、TCP三次握手的意义

- 第一次握手：客户端发送网络包，服务端收到了。 这样服务端就能得出结论：客户端的发送能力、服务端的接收能力是正常的。
- 第二次握手：服务端发包，客户端收到了。 这样客户端就能得出结论：服务端的接收、发送能力，客户端的接收、发送能力是正常的。**不过此时服务器并不能确认客户端的接收能力是否正常。**
  - 两次握手为什么不行：
    - 若只有两次握手，**客户端共发出了两个连接请求报文段，其中第一个丢失，第二个到达了服务端**，但是第一个丢失的报文段只是在**某些网络结点长时间滞留了，延误到连接释放以后的某个时间才到达服务端**，此时**服务端误认为客户端又发出一次新的连接请求**，于是就向客户端**发出确认报文段**，**同意建立连接**，此时客户端忽略服务端发来的确认，也不发送数据，**则服务端一致等待客户端发送数据，浪费资源**。
- 第三次握手：客户端发包，服务端收到了。 这样服务端就能得出结论：客户端的接收、发送能力正常，服务器自己的发送、接收能力也正常。

### 4、TCP四次挥手断开连接的过程？双方的状态

<img src="C:\Users\10690\AppData\Roaming\Typora\typora-user-images\image-20210915214206410.png" alt="image-20210915214206410" style="zoom:67%;" />

刚开始双方都处于 ESTABLISHED 状态，假如是**客户端**先发起关闭请求。四次挥手的过程如下：

- 第一次挥手：客户端发送一个 FIN 报文，报文中会指定一个序列号。此时客户端处于 `FIN_WAIT1` 状态。 即发出**连接释放报文段**（FIN=1，序号seq=u），并停止再发送数据，主动关闭TCP连接，进入FIN_WAIT1（终止等待1）状态，等待服务端的确认。
- 第二次挥手：服务端收到 FIN 之后，会发送 ACK 报文，且把客户端的序列号值 +1 作为 ACK 报文的序列号值，表明已经收到客户端的报文了，此时服务端处于 `CLOSE_WAIT` 状态。 即服务端收到连接释放报文段后即发出**确认报文段**（ACK=1，确认号ack=u+1，序号seq=v），**服务端进入CLOSE_WAIT（关闭等待）状态，此时的TCP处于半关闭状态，客户端到服务端的连接释放**。客户端收到服务端的确认后，进入FIN_WAIT2（终止等待2）状态，等待服务端发出的连接释放报文段。
- 第三次挥手：**如果服务端也想断开连接了，和客户端的第一次挥手一样，发给 FIN 报文，且指定一个序列号。此时服务端处于 `LAST_ACK` 的状态。** 即服务端没有要向客户端发出的数据，服务端发出**连接释放报文段**（FIN=1，ACK=1，序号seq=w，确认号ack=u+1），服务端进入LAST_ACK（最后确认）状态，等待客户端的确认。
- 第四次挥手：客户端收到 FIN 之后，一样发送一个 ACK 报文作为应答，且把服务端的序列号值 +1 作为自己 ACK 报文的序列号值，此时客户端处于 `TIME_WAIT` 状态。需要过一阵子以确保服务端收到自己的 ACK 报文之后才会进入 CLOSED 状态，服务端收到 ACK 报文之后，就处于关闭连接了，处于 `CLOSED` 状态。 即客户端收到服务端的连接释放报文段后，对此发出**确认报文段**（ACK=1，seq=u+1，ack=w+1），客户端进入TIME_WAIT（时间等待）状态。此时TCP未释放掉，需要经过时间等待计时器设置的时间2MSL后，客户端才进入CLOSED状态。

收到一个FIN只意味着在这一方向上没有数据流动。**客户端执行主动关闭并进入TIME_WAIT是正常的，服务端通常执行被动关闭，不会进入TIME_WAIT状态。**

在socket编程中，任何一方执行close()操作即可产生挥手操作。

### 5、TCP四次挥手的意义

因为当服务端收到客户端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中**ACK报文是用来应答的，SYN报文是用来同步的**。但是关闭连接时，**当服务端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉客户端，"你发的FIN报文我收到了"。只有等到我服务端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四次挥手。**

### 6、挥手时等待2MSL的意义?

1. **保证客户端发送的最后一个ACK报文段能够到达服务端。** 这个ACK报文段有可能丢失，使得处于LAST-ACK状态的B收不到对已发送的FIN+ACK报文段的确认，服务端超时重传FIN+ACK报文段，而客户端能在2MSL时间内收到这个重传的FIN+ACK报文段，**接着客户端重传一次确认**，重新启动2MSL计时器，最后客户端和服务端都进入到CLOSED状态，若客户端在TIME-WAIT状态不等待一段时间，而是**发送完ACK报文段后立即释放连接，则无法收到服务端重传的FIN+ACK报文段，所以不会再发送一次确认报文段，则服务端无法正常进入到CLOSED状态。**
2. **防止“已失效的连接请求报文段”出现在本连接中。** 客户端在发送完最后一个ACK报文段后，再经过2MSL，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失，使下一个新的连接中不会出现这种旧的连接请求报文段。

### 7、网络的七层模型/五层模型？每一层的协议？

<img src="C:\Users\10690\AppData\Roaming\Typora\typora-user-images\image-20210915222653855.png" alt="image-20210915222653855" style="zoom:67%;" />

- **应用层**：为用户提供常用的**应用程序**，每个**网络应用对应着不同的协议**。例如文件运输访问和管理，电子邮件等。**HTTP SMTP**

- **表示层**：主要负责**数据格式的转换**，确保一个系统的应用层发送的消息可以被另一个系统的应用层读取；数**据加密**

- **会话层**：**负责网络中两节点的建立**，在数据传输中维护计算机网络中两台计算机之间的通信连接，并决定何时终止通信（建立或解除与其他接点的联系）

- **传输层**：实现两个用户进程间**端到端的可靠通信**，**处理数据包的错误**等传输问题 **TCP UDP**

- **网络层**：逻辑地址寻址，实现不同网**络之间的路径选择** （为数据包选择路由） **IP **

- **数据链路层**：建立**逻辑连接、进行硬件地址寻址**  **ARP**

- **物理层**：主要是**物理介质传输媒介**（**网线或者是无线**），以**二进制数据**形式在物理媒体上传输数据

  

  **物理地址是数据链路层和物理层使用的地址，是网络设备的唯一身份标识；**

  **IP地址是网络层及以上层使用的地址。**

  **填入什么样的mac地址（物理地址）是由网络层的地址解析协议（ARP）完成的。**

### 8、http和https的区别？

1、**HTTP协议**传输的数据都是**未加密**的，也就是明文的，因此**使用HTTP协议传输隐私信息非常不安全**， **HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全**。

- **SSL代表安全套接字层**。它是一种**用于加密和验证应用程序（如浏览器）和Web服务器之间发送的数据的协议**。

2、**https协议需要到ca申请证书**，一般免费证书较少，因而需要一定费用。

3、http和https使用的是**完全不同的连接方式，用的端口也不一样，前者是80，后者是443**。

### 9、在浏览器中输入url地址后显示主页的过程?

1. DNS解析
2. TCP连接
3. 发送HTTP请求
4. 服务器处理请求并返回HTTP报文
5. 浏览器解析渲染页面
6. 连接结束

### 10、TCP粘包问题是什么？你会如何去解决它？【⭐】

- 一个完整的业务可能会被TCP拆分成多个包进行发送，也有**可能把多个小的包封装成一个大的数据包发送**，这个就是TCP的拆包和**粘包问题**。

- 解决：

  - 1、消息定长。
  - 2、在包尾部增加回车或者空格符等特殊字符进行分割
  - 3、将消息分为消息头和消息尾**【项目中使用】**
  - 4、使用其它复杂的协议，如RTMP协议等。

### 11、TCP 利用滑动窗口实现流量控制的机制？

**流量控制是为了控制发送方发送速率，保证接收方来得及接收。TCP 利用滑动窗口实现流量控制。**

TCP 中采用**滑动窗口来进行传输控制**，滑动窗口的大小意味着**接收方还有多大的缓冲区可以用于接收数据**。发送方可以通过滑动窗口的大小来确定应该发送多少字节的数据。当滑动窗口为 0 时，发送方一般不能再发送数据报，但有两种情况除外，一种情况是可以发送紧急数据。

### 12、TCP四大拥塞控制算法

拥塞控制主要是四个算法：1）慢启动，2）拥塞避免，3）拥塞发生，4）快速恢复。

