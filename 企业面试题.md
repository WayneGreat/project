# 企业面试题

### 离职原因

公司准备迁移到东莞，但我自己希望在一线城市发展，所以在金九银十的时间出来求职，希望找到技术更好，学到更多东西的公司（深圳）

公司规模比较小，发展空间不大，所以希望找一些更有技术的公司历练自己，自己也希望能够在这领域能做出成绩，让自己职业更深层次的发展。（上海、广州、杭州）

**！！！hr问自己的工作意向地点，哪里的工作，就说哪里是我的意向工作地点！！！！**

### 迅雷

#### 编程题

- 对于一个整数N（512 <= N <= 1024），计算2的N次方并在屏幕显示十进制结果。

```c++
#include <iostream>
#include <string>

using namespace std;

class PowOf2
{
public:
    string pow2(int n)
    {
        string ret = "1";
        for (int i = 0; i < n; ++i)
        {
            int temp = 0;
            for (int j = ret.size() - 1; j >= 0; --j)//从低位向高位乘2，并处理进位
            {
                temp = ((ret[j] - '0') << 1) + temp / 10;//将此位变为整数进行乘2，加上后一位的进位
                ret[j] = (char)(temp % 10 + '0');//获取个位进行强转为字符，并替换
            }
            if (temp / 10 >= 1)
            {
                ret.insert(ret.begin(), '1');
            }
        }
        return ret;
    }
};

int main()
{
    PowOf2 po2;
    int num;
    cin >> num;
    cout << po2.pow2(num) << endl;
    return 0;
}
```

- 用x,y表示一个整数范围区间，现在输入一组这样的范围区间(用空格隔开)，请输出这些区间的合并。

  ##### **输入描述:**

  ```
  一行整数，多个区间用空格隔开。区间的逗号是英文字符。
  ```

  ##### **输出描述:**

  ```
  合并后的区间，用过空格隔开，行末无空格
  ```

  示例1

  ## 输入

  ```
  1,3 2,5
  ```

  ## 输出

  ```
  1,5
  ```

  示例2

  ## 输入

  ```
  1,3 2,5 8,10 11,15
  ```

  ## 输出

  ```
  1,5 8,10 11,15
  ```

```c++
#include <iostream>
#include <vector>

using namespace std;

int main()
{
    vector<int> vec(1000, 0);
    char ch;
    int num1, num2;
    while (cin >> num1 >> ch >> num2)
    {
        for (int i = num1; i < num2; ++i)
        {
            vec[i] = 1;
        }
    }
    int flag = 0;
    for (int j = 0; j < vec.size(); ++j)
    {
        if (flag == 0 && vec[j] == 1)
        {
            cout << j << ",";
            flag = 1;
        }
        else if (flag == 1 && vec[j] == 0){
            cout << j << " ";
            flag = 0;
        }
    }
    return 0;
}
```



#### 选择题

- 参考以下代码，在大端字节机器中x.c的值为

```c++
union A {
	short c;
	char buf[4];
} x = {0x01, 0x02, 0x03, 0x04}


大端字节：高位值放在内存中的低位地址 ； 小端字节：低位值放在内存中的低位地址。
union联合，结构中的数据共享空间。
题目中字符数组在内存中的存放：                        c在内存中的存放（和buf共享空间）:
A:    0x01     ----->低位地址                      0x01
A+1： 0x02                                        0x02 
A+2:  0x03           由于是大端字节，所以 A+1存放的是低位值，A存放的是高位值，所以c位0x0102，即选A。
A+3:  0x04     ------>高位地址
```

- 以下哪个变量是分配在BSS段

```c++
char s1[100];
int s2 = 0;
static int s3 = 0;

void main() {
	char s4[100];
}

BSS段：通常是指用来存放程序中未初始化的全局变量的一块内存区域；
数据段：通常是指用来存放程序中 已初始化 的 全局变量 的一块内存区域，static意味着在数据段中存放变量；
代码段：通常是指用来存放 程序执行代码 的一块内存区域；
堆：存放进程运行中被动态分配的内存段，它的大小并不固定，可动态扩张或缩减，这一块在程序运行前就已经确定了；
栈：栈又称堆栈， 存放程序的 局部变量 （不包括static声明的变量）。除此以外，在函数被调用时，栈用来传递参数和返回值。
    
单选为A，多选可能是ABC（CSAPP中7.4节可重定位目标文件中有说明.bss用来存放未初始化的全局和静态C变量,以及所有初始化为0的全局和静态变量）
```

- linux文件系统的说法不正确

```
索引节点包含文件的所有信息，包括磁盘上数据的地址和文件类型。每一个文件都包含一个索引节点。×

索引结点中不包括文件的名字，文件名是放在目录块里的。目录块里包含有文件的名字以及此文件的索引结点编号，B中说索引节点包括文件的所有信息，所以错误。
```

- 32位机器上，以下代码的输出是

```c++
char c = -1;
int i0 = c;
int i1 = (unsigned char)c;
printf("%d, %d\n", i0, i1);

[unsigned]char 到 [unsigned]int需要类型提升

类型提升时，有符号型高位补符号位，无符号型高位补0（是对这个数的补码补码补码进行补位！）

char c = -1，所以它的原码是1000 0001，补码是1111 1111

先看i0，是 char->int 的转换，有符号型提升，于是高位补符号位，所以i0的补码就是1111 1111 1111 1111
所以换回原码i0 = -1

再看i1，是先（1）char->unsigned，再（2）unsigned char->int 的转换：
（1）这一步不涉及补位，也就是说数字的补码不变，还是1111 1111，但是这时候已经没有符号位了，变成了无符号型
（2）无符号型提升，高位补0，所以i1的补码就是0000 0000 1111 1111
所以换回原码i1 = 255
```

- Unix系统关于进程和线程的说法，正确的是

  # 正确答案: A B C E  你的答案: A B C (错误)

  ```
  都是调用了clone方法产生新的进程或线程
  创建线程比创建进程要更轻量级
  线程之间共享同一个内存空间
  进程之间共享同一个内存空间 ×
  线程和进程都由内核进行调度
  ```

- 以下哪些不是解释型语言

  # 正确答案: A B C  你的答案: C D (错误)

  ```
  C/C++
  Java
  Go
  Javascript ×
  
  编译型语言：在程序运行之前，有一个单独的编译过程，将程序翻译成机器语言，以后执行这个程序时，就不用再进行翻译了。（C,C++等，需要经过编译（compile）、链接（linker）这两个步骤）
  
  解释型语言：是在运行的时候将程序翻译成机器语言，所以运行速度相对于编译型语言要慢。有良好的平台兼容性，在任何环境中都可以运行，前提是安装了解释器（JavaScript、Python、Erlang、PHP、Perl、Ruby）
  ```

- 给定一个正整数n，求出0到n中有几个数满足其二进制表示不包含连续的1。1<=n<=10^9。
  样例：
  输入：5， 输出：5。
  由于0到5的二进制表示分别为： 0； 1； 10； 11； 100； 101。 这六个数中，只有3的二进制表示包含有连续的1，故答案为5。
  问题：
  若输入为6144，则输出为

```c++
610
    
#include <stdio.h>

int cnt = 0;

void fun(int m)
{
    int flag = 0;
    while(m)
    {
        if(m % 2)//第一次判断是否为1
        {
            flag = 1;
            m /= 2;
            if(m % 2)//第二次判断是否有连续的1
            {
                cnt++;
                break;
            }
        }
        else
            m /= 2;
    }
}

void findtime(int n)
{
    int i;
    for(i = 2; i <= n; i++)//可能包含连续1的数
    {
        fun(i);//查找是否包含连续1
    }
}

int main()
{
    int m;
    scanf("%d",&m);
    findtime(m);
    printf("%d\n",m - cnt + 1);
}
```

- 以下说法不正确的是？

  # 正确答案: A D E  你的答案: D E (错误)

  ```
  类成员的定义必须放在类定义体内部 
  类的一个成员只能具有一种访问控制属性
  在类中,不作特别说明的数据成员均为私有类型
  构造函数和析构函数是特殊的成员函数,因此不允许重载
  类成员的定义必须是成员变量在前、成员函数在后
  ```

- c++11中提供了lambda特征，语法为

```c++
[=] (int x) mutable throw() -> int
{
	// 函數內容
	int n = x + y;
	return n;
}
请问以下哪些正确
```

​	 正确答案: A B C D  你的答案: A B C D (正确)

```c++
lambda常用于封装传给算法的数行简短代码，或是用于解决重复代码的问题
[]表示不捕获任何外部变量，[=]表示通过拷贝捕获所有外部变量
(int x)表示此lambda需要传入一个int参数
lambda在c++14后开始可以支持泛型

============================
lambda的定义和使用是在同一个地方的，对于接受函数指针或函数符的函数，可使用匿名函数定义（lambda）作为其参数，即可封装传递给算法的数行简短代码；

lambad可访问作用域内的任何动态变量；要捕获要使用的变量，可将其名称放到中括号内，只指定变量名，如[z]，将按值访问变量，前加&，按引用访问，[&]访问所有引用变量，[=]能按值访问所有动态变量，也可混合使用。[ ]仅表示lambda引导符；

bool f3(int x)｛return x%3==0；｝对应的lambda为   [ ] (int x) {return x%3==0;}  使用[ ]代替了函数名，没有声明返回类型，返回类型相当于使用decltyp根据返回值自动推断，如果lambda不包含返回语句，推断出的返回语句为void并且仅当表达式完全由一条返回值语句构成时，自动推断才有效，否则要新增返回类型后置语法：[ ] (double x) ->double {int y=x; return x-y;}
```

- 在32位大端模式处理器上变量b等于？

```c++
unsigned int a= 0x1234;
unsigned char b=*(unsigned char *)&a;

unsigned int 是四个字节
0x1234 才两个字节
因为0x1234 = 0x00001234
且为大端模式(高字节放在低地址)
所以获得的为0x00
```

- 如果ip分片报文丢失，下面说法正确的是

  # 正确答案: B  你的答案: D (错误)

  ```
  ip层负责重发
  上层协议（例如tcp）负责重发
  链路层负责重发
  只有传输层（例如tcp）会进行分片，ip层不负责分片 ×
  
  
  ip层也要进行分段，当本端向目标端发送信息时(从ip---ip)如果你的IP数据报大于其某段网络限定值（MTU），就会进行分段进行传输
  ```

- 下面的陈述中哪个是正确的？

  # 正确答案: A  你的答案: B D (错误)

  ```c++
  类必须提供至少一个构造函数
  默认构造函数的形参列表中没有形参。
  如果一个类没有有意义的默认值，则该类不应该提供默认构造函数。
  如果一个类没有定义默认构造函数，则编译器会自动生成一个，同时将每个数据成员初始化为相关类型的默认值。
      
      
      
  A选项：一个类必须拥有构造函数，否则没发创建一个对象，达不了类的目的。
  一开始本人对构造函数为私有的情况有所顾忌，但构造函数私有只是不想在外部直接定义对象出来，并不是说不可以定义对象。考虑实现一个单例类的例子：
  
  class A{
  public:
      void show( ){
          cout<<val<<endl;
      }
      static A* GetInstance( )
      {
          static A instance;
          return &instance;
      }
  private:
      A() { }
      static int val;
  };
  int A::val = 0;
  
  B选项：默认的构造函数除了构造还有 拷贝构造 右值构造（c++11），它们两个是带有参数的
  D选项：编译器生成的默认构造函数只负责初始化有默认构造函数的成员对象，其他的一律不负责（int 等内置类型数据成员的初始化，这个该由程序员去做。
  ```

- 哪个类定义可能需要一个复制构造函数？

  # 正确答案: B C  你的答案: A B D (错误)

  ```
  包含四个 float 成员的 Point3w 类
  Matrix 类，其中，实际矩阵在构造函数中动态分配，在析构函数中删除
  Payroll 类，在这个类中为每个对象提供唯一ID
  Word 类，包含一个 string 和一个以行列位置对为元素的 vector
  
  类需要定义一个新的复制构造函数，说明默认的复制构造函数不能满足需求：
  A选项可以用默认的复制构造函数
  B选项需要动态分配内存，需要
  C选项根据存在的Payroll复制一份相同的副本，不能使得对象ID唯一
  D选项可以调用string/vector类的复制构造函数
  ```

- 下列关于C++类的说法中错误的有哪些？

  # 正确答案: B C D  你的答案: A B C (错误)

  ```
  一个空类默认会生成构造函数,拷贝构造函数,赋值操作符,析构函数
  一个类可以有多个析构函数
  类中析构函数可以为virtual,可以被重载
  类的构造函数如果都不是public访问属性,则类的实例无法创建
  ```

#### 面经

1.new delete和malloc free的区别 、new出来的对象可以用free吗？ malloc出来的东西可以用delete吗？ 

4.虚函数底层（虚函数表怎么调用）？ 

5.class A{ 

  virtual void show(); 

  }； 

  class B:public A{ 

  void show(); 

  }; 

  A* a = new B; 

  a->show(); 

  调用哪个show函数？ 

  6.析构函数为什么要声明为virtual？ 

  7.B* b = new B; 

  delete b会不会运行类A的析构函数？ 

  8.public privite protected继承的区别？ 

  9.class A 

  { 

​    virtual void show(); 


  }; 

  class B:private C{ 

  void run(){ 

  show(); 

  } 

  };能不能正常的编译运行？ 

  10.在构造函数里面能调用虚函数吗？析构函数里面能调用虚函数吗？ 

  11.继承层次里面，先调用父类的构造函数还是先调用子类的？ 析构？ 

  12.C++中vector和list插入删除情况下迭代器失效情况？ 

  13.vector扩容？ 

  14.n个元素依次插入vector、map的时间复杂度？ 

- 问题： 将N个元素使用push_back插入到vector中， 求push_back操作的复杂度。


  简单分析如下：

  ```c++
  考虑vector每次内存扩充两倍的情况。
  
  如果我们插入N个元素， 则会引发lgN次的内存扩充，而每次扩充引起的元素拷贝次数为
  
                                    2^0,  2^1, 2^2, ..., 2^lgN.
  
  把所有的拷贝次数相加得到
  
                  2^0 + 2^1 + 2^2 + ... + 2^lgN = 2 * 2^lgN - 1 约为 2N次
  
  共拷贝了N次最后一个元素， 所以总的操作大概为3N
  
  所以， 每个push_back操作分摊3次， 是O(1) 的复杂度。
  ===========================================
  map insert
  复杂度
  如果插入单个元素且无暗示，时间复杂度为 O(logn)，其中 n 为容器的大小。
  
  如果插入单个元素且有最优位置（Position）暗示，时间复杂度为 O(1)，这是一个平均分摊后的常值（Amortized constant）。
  
  如果插入多个元素，时间复杂度为 O(nlogn)，“第一个” n 为插入元素数，“第二个” n 为插入元素数加容器大小。如果插入的范围中的元素已经按同样的排序规则排序，执行过程将被优化，时间复杂度甚至会降到 O(n)。
  
  迭代器有效性
  不会改变。
  
  ```


  16.无序n个元素数组，最快找出前k个最小元素？ 【⭐】【有编程题】

- 使用快排思想O(n),但会修改原数组，

- 使用优先级队列O(1)获取最大值，O(logk)完成插入删除操作
- 使用set或multiset（红黑树），O(logk)完成查找、插入、删除操作

  17.创建堆的时间复杂度？ https://blog.csdn.net/RunningBeef/article/details/108752281

- 两种方式

```c++
（1）自顶向下的建堆方式

这种建堆的方法具有O(n*log2n)的时间复杂度。从根结点开始，然后一个一个的把结点插入堆中。当把一个新的结点插入堆中时，需要对结点进行调整，以保证插入结点后的堆依然是大根堆。如下图所示，是采用自顶向下的方法建立的大根堆。

 

其中h = log2(n+1)-1，第k层结点个数为2k个(当然最后一层结点个数可能小于2h)。第k层的一个结点插入之后需要进行的比较(移动)次数为k。于是总的比较(移动)次数为∑k*2k(k = 0,1,2,...,h)。可以求得∑k*2k(k = 0,1,2,...,h)=(log2(n+1)-2)*(n+1)+2 = O(n*log2n)

 

（2）自下向上的建堆方式

这种建堆的方法具有O(n)的时间复杂度。如下图所示，从第一个非叶子结点开始进行判断该子树是否满足堆的性质。如果满足就继续判断下一个点。否则，如果子树里面某个子结点有最大元素，则交换他们，并依次递归判断其子树是否仍满足堆性质。

 
因为调整根结点以及其左右孩子的位置的复杂度是O(1),再加上对其子树的递归判断是否满足堆性质需O(h),而在任意高度h上，至多有[n/2^(h+1)]个结点。则总共的时间复杂度为∑h*(n)/(2(h+1)).根据调和级数的积分公式可得，时间复杂度为O(n)。
```

  18.TCP三次握手？ 

  19.TIME_WAIT？ 

  20.accept在三次握手哪个阶段？ 

- 18、19、20  画了图，看图回答

  21.滑动窗口  发送窗口 区别？ 

-  滑动窗口（发送窗口和接收窗口）

  - TCP的滑动窗口主要有两个作用，一是提供TCP的可靠性，二是提供TCP的流控特性。同时滑动窗口机制还体现了TCP面向字节流的设计思路。

  -  发送窗口与接收窗口关系

    TCP是双工的协议，**会话的双方都可以同时接收、发送数据**。TCP会话的**双方都各自维护一个“发送窗口”和一个“接收窗口”**。其中**各自的“接收窗口”大小取决于应用、系统、硬件的限制**（TCP传输速率不能大于应用的数据处理速率）。**各自的“发送窗口”则要求取决于对端通告的“接收窗口”，要求相同**。

22.流量控制 拥塞控制的区别？ 

  - 流量控制是端到端的控制，例如A通过网络给B发数据，A发送的太快导致B没法接收(B缓冲窗口过小或者处理过慢)，这时候的控制就是流量控制，原理是通过滑动窗口的大小改变来实现。 
    拥塞控制是A与B之间的网络发生堵塞导致传输过慢或者丢包，来不及传输。防止过多的数据注入到网络中，这样可以使网络中的路由器或链路不至于过载。拥塞控制是一个全局性的过程，涉及到所有的主机、路由器，以及与降低网络性能有关的所有因素。

  23.滑动窗口在哪个端？ 

<img src="C:\Users\10690\AppData\Roaming\Typora\typora-user-images\image-20210924184242300.png" alt="image-20210924184242300" style="zoom:50%;" />

  25.[客户端]()有几个线程？ （项目中）

  26.epoll LT ET区别？

epoll提供两种工作模式：LT 和 ET。

**LT模式是epoll默认的工作方式**，相当于一个**效率很高的poll模型**；而ET是**高效**的工作方式。

LT 和 ET本质的区别是：

| lt   | 当检测到epoll_wait 上有就绪事件的时候，可以不立即执行，当下次再次调用epoll_wait时还会提醒 |
| ---- | ------------------------------------------------------------ |
| et   | 当检测到epoll_wait 上有就绪的事件的时候，就必须处理该事件，否则下次调用epoll_wait 的时候，也不会提醒。 |

客户端向服务器发送数据，
lt 模式下，如果服务端一次没有将全部的数据读完，则epoll_wait 会再次提醒，直到把所有的数据全部读完为止
et 模式下，如果未将全部的数据读完，则epoll_wait 不再提醒，剩余的数据还在接收方的接收缓冲区中。

netstat -napt 可以查看接收缓冲区的内容

ET在很大程度上减少了epoll事件被重复触发的次数，效率较高，因此，在使用ET模式时，必须使用非阻塞的接口，以避免由于一个文件描述符的读或写阻塞操作把处理多个文件描述符的任务饿死（当接受数据缓冲区比较小时，需要循环接受数据）



