# 企业面试题

### 离职原因

公司准备迁移到东莞，但我自己希望在一线城市发展，所以在金九银十的时间出来求职，希望找到技术更好，学到更多东西的公司（深圳）

公司规模比较小，发展空间不大，所以希望找一些更有技术的公司历练自己，自己也希望能够在这领域能做出成绩，让自己职业更深层次的发展。（上海、广州、杭州）

**！！！hr问自己的工作意向地点，哪里的工作，就说哪里是我的意向工作地点！！！！**

### 迅雷

#### 编程题

##### 对于一个整数N（512 <= N <= 1024），计算2的N次方并在屏幕显示十进制结果。

```c++
#include <iostream>
#include <string>

using namespace std;

class PowOf2
{
public:
    string pow2(int n)
    {
        string ret = "1";
        for (int i = 0; i < n; ++i)
        {
            int temp = 0;
            for (int j = ret.size() - 1; j >= 0; --j)//从低位向高位乘2，并处理进位
            {
                temp = ((ret[j] - '0') << 1) + temp / 10;//将此位变为整数进行乘2，加上后一位的进位
                ret[j] = (char)(temp % 10 + '0');//获取个位进行强转为字符，并替换
            }
            if (temp / 10 >= 1)
            {
                ret.insert(ret.begin(), '1');
            }
        }
        return ret;
    }
};

int main()
{
    PowOf2 po2;
    int num;
    cin >> num;
    cout << po2.pow2(num) << endl;
    return 0;
}
```

##### 用x,y表示一个整数范围区间，现在输入一组这样的范围区间(用空格隔开)，请输出这些区间的合并。

**输入描述:**

```
一行整数，多个区间用空格隔开。区间的逗号是英文字符。
```

 **输出描述:**

```
合并后的区间，用过空格隔开，行末无空格
```

示例1

 输入

```
1,3 2,5
```

 输出

```
1,5
```

示例2

 输入

```
1,3 2,5 8,10 11,15
```

输出

```
1,5 8,10 11,15
```

```c++
#include <iostream>
#include <vector>

using namespace std;

int main()
{
    vector<int> vec(1000, 0);
    char ch;
    int num1, num2;
    while (cin >> num1 >> ch >> num2)
    {
        for (int i = num1; i < num2; ++i)
        {
            vec[i] = 1;
        }
    }
    int flag = 0;
    for (int j = 0; j < vec.size(); ++j)
    {
        if (flag == 0 && vec[j] == 1)
        {
            cout << j << ",";
            flag = 1;
        }
        else if (flag == 1 && vec[j] == 0){
            cout << j << " ";
            flag = 0;
        }
    }
    return 0;
}
```

##### 有n个文件的长度记载在一个无符号64位整数数组中unsigned__int64 file_length[n]，把这n 个文件从逻辑上按序首尾拼接在一起形成一个逻辑上的大文件，然后以每块长度为unsigned block_length把这个逻辑上的大文件划分成大小相等的数据块（当然，最后一块有可能比block_length小），请定义和实现一个函数，把边界块的序号集合返回给函数的调用者（第一个数据块序号为0）。

注：边界块指的是跨多个文件的数据块。

```c++
#include <iostream>
#include <vector>
using namespace std;
 
#define N 10 
unsigned __int64 file_length[N]={15,120,250,600,5,5,30,65,70,100};
unsigned block_length=30;
 
vector<int> getIndex(unsigned __int64 *file_length,int n,unsigned block_size)
{
    vector<int> res;
    int index=0; //block序号
    int i=0; //file_length序号
    while(i<n)
    {
        if(file_length[i]==0) //特殊情况，某个文件长度为0则跳过
        {
            i++;         
            continue;
        }
        if(file_length[i]<block_size) //某个文件长度小于块
        {
            res.push_back(index);
            int j=i+1;
            int sum=file_length[i];
            //一个block可能跨很多文件，将后面的文件长度累加起来，只到超过一个block
            while(j<n)
            {
                sum+=file_length[j];
                if(sum>block_size)
                    break;
                j++;
            }
            file_length[j]=sum-block_size;
            i=j;
        }
        else if(file_length[i]==block_size) //如果刚好相等就不算跨文件
            i++;
        else
            file_length[i]-=block_size; //如果文件大于一个块，则分割为剩下的
 
        index++; //块序号自增
    }
    return res;
}
 
int main(int argc,char *argv[])
{
     
    vector<int> res=getIndex(file_length,N,block_length);
    getchar();
 
    return 0;
}
```

##### 请实现一个函数，把两个从大到小的有序链表合并成一个链表，新的链表是一个从小到大的有序链表。

```c++
struct list
{
    int value;
    list* next;
};
list * merge (list *list1_head, list*list2_head);

//先反转再合并
```

##### 如果两个英文单词，组成它们的字符集合相同，而且相同字符出现的次数也相同，则称这两个词匹配：比如说：同”abbc”与词 ”babc”是匹配的。有一个词典，存储在字符串数组const char* dictionary[n]中，数组的每一个元素是一个词。对于任意给出的句子。句子中的单词使用空格分割。请实现以下函数，判断句子中是否有词和词典中的词匹配。

bool is_matching( const char* dictionary[],int n, const char* sentence);

```c++
#include <iostream>
#include <cstdlib>
#include <vector>
 
using namespace std;
 
bool isMatch(const char*str1, const char *str2)
{
    int len1 = 0, len2 = 0;
    const char *p = str1, *q = str2;
    /*求两个字符串长度*/
    while (*p++ != '\0')
        ++len1;
    while (*q++ != '\0')
        ++len2;
 
    if (len1 != len2)
        return false;
 
    vector<char> vMap(256, 0);
    p = str1;
    while (*p != '\0')
    {
        ++vMap[*p];
        ++p;
    }//while
 
    /*验证匹配性*/
    q = str2;
    while (*q != '\0')
    {
        if (--vMap[*q] < 0)
            return false;
        ++q;
    }//while
    return true;
}
 
bool is_matching(const char* dictionary[], int n, const char* sentence)
{
    if (!sentence)
        return false;
 
    int len = 0;
    const char *p = sentence;
    while (*p++ != '\0')
        ++len;
 
    char *word = new char[len + 1];
    word[0] = '\0';
 
    /*单词长度计数sz*/
    int sz = 0;
    p = sentence;
    while (*p != '\0')
    {
        if (*p == ' ')
        {
            word[sz] = '\0';
            for (int i = 0; i < n; ++i)
            {
                if (isMatch(word,dictionary[i]))
                    return true;
            }//for
            sz = 0;
            word[sz] = '\0';
        }
        else{
            word[sz++] = *p;
        }//else
 
        ++p;
    }//while
    /*查找最后一个单词在不在词典中*/
    word[sz] = '\0';
    for (int i = 0; i < n; ++i)
    {
        if (isMatch(word, dictionary[i]))
            return true;
    }//for
 
    return false;
}
 
int main()
{
    const char *dictionary[] = { "I", "am", "a", "good", "student." };
 
    const char *s = "very good ";
 
    cout << is_matching(dictionary, 5, s) << endl;
 
    system("pause");
    return 0;
 
 
}
```

##### 实现strtol函数，其原型如为int strtol(const char *num_str, char **endptr, int base)，num_str存放待转换的字符串，可以是负数也可以是正数；endptr指向第一个非法字符的地址，如果endptr为null则不指向第一个非法字符的地址；base用于指示进制，若base为0，则根据num_str的指示来转换。函数必须检查溢出，如果正数溢出，返回int_max；若负数溢出，返回int_min。

```c++
#include<iostream>
using namespace std;
 
const int int_max = 2147483647;
const int int_min = -2147483648;
 
bool isAlph(char num)
{
    if ((num >= 'A'&& num <= 'Z') || (num >= 'a'&& num <= 'z'))
        return true;
    else
        return false;
}
 
bool isDigit(char num)
{
    if ((num >= '0'&& num <= '9'))
        return true;
    else
        return false;
}
 
char toLower(char num)
{
    char result = num;
    if (num >= 'A' && num <= 'Z')
        result += 32;
    return result;
}
int strtoLL(const char *num_str, char **endptr, int base)
{
    long long result = 0;
    long long value;
    if (!base)
    {
        if (*num_str == '0')
        {
            num_str++;
            if (*num_str == 'x' || *num_str == 'X')
            {
                base = 16;
                num_str++;
            }
            else
                base = 8;
        }
        else
            base = 10;
    }
    while (true)
    {
        if (isAlph(*num_str) || isDigit(*num_str))
        {
            value = isAlph(*num_str) ? toLower(*num_str) - 'a' + 10 : *num_str - '0';
            if (value >= base)
                break;
            result = result*base + value;
            if (result > int_max)
                result = int_max;  
            if (result < int_min)
                result = int_min;
            num_str++;
        }
        else
            break;
    }
    if (endptr)
        *endptr = const_cast<char*> (num_str);
    return result;
}
 
int Mystrtol(const char *num_str, char **endptr, int base)
{
    if (*num_str == '-')
    {
         long result = strtoLL(num_str + 1, endptr, base);
         if (result == int_max)
             return int_min;
         else
             return -result;
    }
    return strtoLL(num_str, endptr, base);
}
 
int main()
{
    char *str = "0123456789ABCDEFGHItest";
    char *temp;
    cout << "******Mystrtol********" << endl;
    int result = Mystrtol(str, &temp,0);
    cout << result << endl;
    cout << temp << endl;
    cout << "******strtol**********" << endl;
    result = strtol(str, &temp,0);
    cout << result << endl;
    cout << temp << endl;
    system("pause");
    return 0;
}
```

##### 一亿个数找最大的1000个数，要求效率高占用内存少。函数原型为：find_max_data(int* source_data, int* max_data)，其中source_data是存放一亿个数的数组，max_data用于存放其中最大的1000个数。

````c++
/* 基数排序  */
#include <iostream>
#include <stdlib.h>
#include <ctime>
#include <algorithm>
#include <cassert>
#include "windows.h"
using namespace std;
#define MAXN 100000000 #define MAXM 1000
void find_max_data0( int dest[], int m, int src[], int n )
{
    fill( dest, dest + n, -INT_MAX );
    for ( int i = 0; i < n; i++ )
    {
        for ( int j = 0; j < m; j++ )
        {
            if ( src[i] > dest[j] )
            {
                dest[j] = src[i];
                break;
            }
        }
    }
}
void find_max_data1( int dest[], int m, int src[], int n )
{
    make_heap( src, src + n );
    for( int i = 0; i < m; i++ )
    {
        dest[i] = src[0];
        pop_heap( src, src + n-- );
    }
}
void radix_sort( int *src, int n )
{
    int *tmp = new int[MAXN];  int cnt[256];
    for( int i = 0; i < 4; i++ ) {
        memset( cnt, 0, sizeof(cnt) );
        for( int j = 0; j < MAXN; j++ )
        {
            cnt[ ( src[j] >> (8 * i) ) & 0xff ]++;
        }
        for ( int j = 1; j < 256; j++ )
        {
            cnt[j] = cnt[j - 1] + cnt[j];
        }
        for( int j = MAXN - 1; j >= 0; j-- )
        {
            tmp[ -- cnt[ ( src[j] >> (8 * i) ) & 0xff ] ] = src[j]; swap( src, tmp );
        }
    }
    delete [] tmp;
}
void find_max_data2( int dest[], int m, int src[], int n )
{
    radix_sort( src, n );
    int j = 0;
    for( int i = n - 1; i >= n - m; i-- )
    {
        dest[j++] = src[i];
    }
}
int src[MAXN];
int main()
{
    ( (unsigned int) time( NULL ) );
    src[i] = abs( i * 6516187 );
    DWORD t1, t2;
    t1  = GetTickCount();
    find_max_data2( dest2, MAXM, src, MAXN );  
    t2 = GetTickCount();
    printf( "find_max_data2 time cost:%dn", t2 - t1 );
    for( int i = 0; i < MAXM; i++ )
    {
        printf( "n" );  return 0;
    }
}
````

##### 将一个集合拆分成两个不相交的子集，两个子集元素之和相等，如{1, 2, 3, 4, 5, 6, 7}，拆分成： {2, 5, 7}, {1, 3, 4, 6} 给出一个集合，求所有符合上面要求的拆分，效率最高分越高，函数原型为int cal_num(int n);

```c++
//这个是求解的,复杂度应该是解空间的大小
void out(int ary[], int n)
{
    for (int i = 0; i < n; i++) {
        printf("%d ", ary[i]);
    }
    printf("\n");
}
bool kubi(int sum, int ary[], int max, int level = 0)
{
    bool flag = false;
    if (max >= sum) {
        ary[level] = sum;
        out(ary, level + 1);
        flag = true;
        max = sum - 1;
    }
    for (int i = max; i > 0; i--) {
        ary[level] = i;
        if (kubi(sum - i, ary, i - 1, level + 1))
            flag = true;
        else
            break;
    }
    return flag;
}
```

##### 输入一个有符号整数，输出该整数的反转值。

```c++
#include<iostream>
using namespace std;
int main()
{
    int input;
    cin >> input;
    int output = 0;
    while(input!=0)
    {
        output=output*10+input%10;
        input/=10;
    }
    cout<<output;
}
```

##### 给定整数n，取若干个1到n的整数可求和等于整数m，编程求出所有组合的个数。比如当n=6，m=8时，有四种组合：[2,6], [3,5], [1,2,5], [1,3,4]。限定n和m小于120

```c++
#include<bits/stdc++.h>
using namespace std;
int main()
{
    int n,m;
    cin>>n>>m;
    vector<int> dp(m+1,0);
    dp[0]=1;
    for(int i=1;i<=n;i++) //注意是1到n
    {
        for(int j=m;j>=i;j--)
        {
            dp[j]=dp[j]+dp[j-i];
        }
    }
    cout<<dp[m]<<endl;
}

//0-1背包问题
```

##### 有一幢100层高的大楼，给你两个完全相同的玻璃围棋子。假设从某一层开始，丢下玻璃棋子就会破碎。那么怎么利用手中的两颗棋子，用一种什么样的最优策略，知道这个临界的层高呢？

```c++
采用二分法！
（1）在50层的时候丢下一个玻璃棋子，如果玻璃碎了，继续在25层丢下另一个玻璃棋子；如果第一个玻璃棋子没有碎，则在75层丢下第二枚棋子。
（2）在对应的位置判断第二枚棋子是否碎了，没有碎则继续二分查找处理
```

##### 用c++写一个函数，如Foo(const char *str)，打印出str的全排列，如abc的全排列：abc, acb, bca, dac, cab,cba

```c++
/*
好题及难题
全排列：字符串或一串数字 => 回溯法（视频地址：https://www.bilibili.com/video/BV1dx411S7WR）
*/
#include <iostream>
#include <vector>
#include <string>
#include <algorithm>
#include <unordered_map>

using std::cout;
using std::endl;
using std::vector;
using std::string;
using std::swap;
using std::sort;
using std::unordered_map;

class Solution
{
public:
    vector<string> permutation(string s)
    {
        if (0 == s.size()) return vector<string>();
        permutationCore(s, 0, s.size() - 1);
        sort(_result.begin(), _result.end());//将字符串按字典序排序
        return _result;
    }

private:
    void permutationCore(string &s, int start, int end)
    {
        if (start == end) {//将排列加入到vector中
            _result.push_back(s);
            return;
        }
        unordered_map<int, int> visited;         //防止含有重复的字符时的重复排列
        for (int idx = start; idx <= end; ++idx) {//回溯法
            if (visited[s[idx]] == 1) {
                continue;
            }
            swap(s[idx], s[start]);
            //交换后，对start后的字符串进行排列
            permutationCore(s, start + 1, end);
            //排列完成后，回归到原来的交换前的状态
            swap(s[idx], s[start]);
            visited[s[idx]] = 1;
        }
    }

private:
    vector<string> _result;//排列
};
```

##### 求出一字符串中最长的数字串。比如as123cdf1234f，返回1234，char* FindNumber(char * out,char *in)。

```c++
#include 
#include 
#include 
using namespace std;

char* FindNumber(char * out, char *in) {
 if (!out || !in)
  return NULL;

 char *tmp = (char*)malloc(strlen(in) + 1);
 int n=0;
 strcpy(out, "");
 for (int i = 0; in[i] != '\0'; ++i) {
  if ((in[i] > '9' || in[i] < '0')&&n!=0) {
   tmp[n] = '\0';
   n = 0;
   if (strlen(out) < strlen(tmp))
    strcpy(out, tmp);
  }
  else {
   tmp[n++] = in[i];
  }
 }
 tmp[n] = '\0';
 if (strlen(out) < strlen(tmp))
  strcpy(out, tmp);
 free(tmp);
 return out;
}

int main() {
 char out[50];
 printf(FindNumber(out, "124567812151as123cdf1234f1233456"));
 return 0;
}
```



#### 选择题

- 参考以下代码，在大端字节机器中x.c的值为

```c++
union A {
	short c;
	char buf[4];
} x = {0x01, 0x02, 0x03, 0x04}


大端字节：高位值放在内存中的低位地址 ； 小端字节：低位值放在内存中的低位地址。
union联合，结构中的数据共享空间。
题目中字符数组在内存中的存放：                        c在内存中的存放（和buf共享空间）:
A:    0x01     ----->低位地址                      0x01
A+1： 0x02                                        0x02 
A+2:  0x03           由于是大端字节，所以 A+1存放的是低位值，A存放的是高位值，所以c位0x0102，即选A。
A+3:  0x04     ------>高位地址
```

- 以下哪个变量是分配在BSS段

```c++
char s1[100];
int s2 = 0;
static int s3 = 0;

void main() {
	char s4[100];
}

BSS段：通常是指用来存放程序中未初始化的全局变量的一块内存区域；
数据段：通常是指用来存放程序中 已初始化 的 全局变量 的一块内存区域，static意味着在数据段中存放变量；
代码段：通常是指用来存放 程序执行代码 的一块内存区域；
堆：存放进程运行中被动态分配的内存段，它的大小并不固定，可动态扩张或缩减，这一块在程序运行前就已经确定了；
栈：栈又称堆栈， 存放程序的 局部变量 （不包括static声明的变量）。除此以外，在函数被调用时，栈用来传递参数和返回值。
    
单选为A，多选可能是ABC（CSAPP中7.4节可重定位目标文件中有说明.bss用来存放未初始化的全局和静态C变量,以及所有初始化为0的全局和静态变量）
```

- linux文件系统的说法不正确

```
索引节点包含文件的所有信息，包括磁盘上数据的地址和文件类型。每一个文件都包含一个索引节点。×

索引结点中不包括文件的名字，文件名是放在目录块里的。目录块里包含有文件的名字以及此文件的索引结点编号，B中说索引节点包括文件的所有信息，所以错误。
```

- 32位机器上，以下代码的输出是

```c++
char c = -1;
int i0 = c;
int i1 = (unsigned char)c;
printf("%d, %d\n", i0, i1);

[unsigned]char 到 [unsigned]int需要类型提升

类型提升时，有符号型高位补符号位，无符号型高位补0（是对这个数的补码补码补码进行补位！）

char c = -1，所以它的原码是1000 0001，补码是1111 1111

先看i0，是 char->int 的转换，有符号型提升，于是高位补符号位，所以i0的补码就是1111 1111 1111 1111
所以换回原码i0 = -1

再看i1，是先（1）char->unsigned，再（2）unsigned char->int 的转换：
（1）这一步不涉及补位，也就是说数字的补码不变，还是1111 1111，但是这时候已经没有符号位了，变成了无符号型
（2）无符号型提升，高位补0，所以i1的补码就是0000 0000 1111 1111
所以换回原码i1 = 255
```

- Unix系统关于进程和线程的说法，正确的是

  # 正确答案: A B C E  你的答案: A B C (错误)

  ```
  都是调用了clone方法产生新的进程或线程
  创建线程比创建进程要更轻量级
  线程之间共享同一个内存空间
  进程之间共享同一个内存空间 ×
  线程和进程都由内核进行调度
  ```

- 以下哪些不是解释型语言

  # 正确答案: A B C  你的答案: C D (错误)

  ```
  C/C++
  Java
  Go
  Javascript ×
  
  编译型语言：在程序运行之前，有一个单独的编译过程，将程序翻译成机器语言，以后执行这个程序时，就不用再进行翻译了。（C,C++等，需要经过编译（compile）、链接（linker）这两个步骤）
  
  解释型语言：是在运行的时候将程序翻译成机器语言，所以运行速度相对于编译型语言要慢。有良好的平台兼容性，在任何环境中都可以运行，前提是安装了解释器（JavaScript、Python、Erlang、PHP、Perl、Ruby）
  ```

- 给定一个正整数n，求出0到n中有几个数满足其二进制表示不包含连续的1。1<=n<=10^9。
  样例：
  输入：5， 输出：5。
  由于0到5的二进制表示分别为： 0； 1； 10； 11； 100； 101。 这六个数中，只有3的二进制表示包含有连续的1，故答案为5。
  问题：
  若输入为6144，则输出为

```c++
610
    
#include <stdio.h>

int cnt = 0;

void fun(int m)
{
    int flag = 0;
    while(m)
    {
        if(m % 2)//第一次判断是否为1
        {
            flag = 1;
            m /= 2;
            if(m % 2)//第二次判断是否有连续的1
            {
                cnt++;
                break;
            }
        }
        else
            m /= 2;
    }
}

void findtime(int n)
{
    int i;
    for(i = 2; i <= n; i++)//可能包含连续1的数
    {
        fun(i);//查找是否包含连续1
    }
}

int main()
{
    int m;
    scanf("%d",&m);
    findtime(m);
    printf("%d\n",m - cnt + 1);
}
```

- 以下说法不正确的是？

  # 正确答案: A D E  你的答案: D E (错误)

  ```
  类成员的定义必须放在类定义体内部 
  类的一个成员只能具有一种访问控制属性
  在类中,不作特别说明的数据成员均为私有类型
  构造函数和析构函数是特殊的成员函数,因此不允许重载
  类成员的定义必须是成员变量在前、成员函数在后
  ```

- c++11中提供了lambda特征，语法为

```c++
[=] (int x) mutable throw() -> int
{
	// 函數內容
	int n = x + y;
	return n;
}
请问以下哪些正确
```

​	 正确答案: A B C D  你的答案: A B C D (正确)

```c++
lambda常用于封装传给算法的数行简短代码，或是用于解决重复代码的问题
[]表示不捕获任何外部变量，[=]表示通过拷贝捕获所有外部变量
(int x)表示此lambda需要传入一个int参数
lambda在c++14后开始可以支持泛型

============================
lambda的定义和使用是在同一个地方的，对于接受函数指针或函数符的函数，可使用匿名函数定义（lambda）作为其参数，即可封装传递给算法的数行简短代码；

lambad可访问作用域内的任何动态变量；要捕获要使用的变量，可将其名称放到中括号内，只指定变量名，如[z]，将按值访问变量，前加&，按引用访问，[&]访问所有引用变量，[=]能按值访问所有动态变量，也可混合使用。[ ]仅表示lambda引导符；

bool f3(int x)｛return x%3==0；｝对应的lambda为   [ ] (int x) {return x%3==0;}  使用[ ]代替了函数名，没有声明返回类型，返回类型相当于使用decltyp根据返回值自动推断，如果lambda不包含返回语句，推断出的返回语句为void并且仅当表达式完全由一条返回值语句构成时，自动推断才有效，否则要新增返回类型后置语法：[ ] (double x) ->double {int y=x; return x-y;}
```

- 在32位大端模式处理器上变量b等于？

```c++
unsigned int a= 0x1234;
unsigned char b=*(unsigned char *)&a;

unsigned int 是四个字节
0x1234 才两个字节
因为0x1234 = 0x00001234
且为大端模式(高字节放在低地址)
所以获得的为0x00
```

- 如果ip分片报文丢失，下面说法正确的是

  # 正确答案: B  你的答案: D (错误)

  ```
  ip层负责重发
  上层协议（例如tcp）负责重发
  链路层负责重发
  只有传输层（例如tcp）会进行分片，ip层不负责分片 ×
  
  
  ip层也要进行分段，当本端向目标端发送信息时(从ip---ip)如果你的IP数据报大于其某段网络限定值（MTU），就会进行分段进行传输
  ```

- 下面的陈述中哪个是正确的？

  # 正确答案: A  你的答案: B D (错误)

  ```c++
  类必须提供至少一个构造函数
  默认构造函数的形参列表中没有形参。
  如果一个类没有有意义的默认值，则该类不应该提供默认构造函数。
  如果一个类没有定义默认构造函数，则编译器会自动生成一个，同时将每个数据成员初始化为相关类型的默认值。
      
      
      
  A选项：一个类必须拥有构造函数，否则没发创建一个对象，达不了类的目的。
  一开始本人对构造函数为私有的情况有所顾忌，但构造函数私有只是不想在外部直接定义对象出来，并不是说不可以定义对象。考虑实现一个单例类的例子：
  
  class A{
  public:
      void show( ){
          cout<<val<<endl;
      }
      static A* GetInstance( )
      {
          static A instance;
          return &instance;
      }
  private:
      A() { }
      static int val;
  };
  int A::val = 0;
  
  B选项：默认的构造函数除了构造还有 拷贝构造 右值构造（c++11），它们两个是带有参数的
  D选项：编译器生成的默认构造函数只负责初始化有默认构造函数的成员对象，其他的一律不负责（int 等内置类型数据成员的初始化，这个该由程序员去做。
  ```

- 哪个类定义可能需要一个复制构造函数？

  # 正确答案: B C  你的答案: A B D (错误)

  ```
  包含四个 float 成员的 Point3w 类
  Matrix 类，其中，实际矩阵在构造函数中动态分配，在析构函数中删除
  Payroll 类，在这个类中为每个对象提供唯一ID
  Word 类，包含一个 string 和一个以行列位置对为元素的 vector
  
  类需要定义一个新的复制构造函数，说明默认的复制构造函数不能满足需求：
  A选项可以用默认的复制构造函数
  B选项需要动态分配内存，需要
  C选项根据存在的Payroll复制一份相同的副本，不能使得对象ID唯一
  D选项可以调用string/vector类的复制构造函数
  ```

- 下列关于C++类的说法中错误的有哪些？

  # 正确答案: B C D  你的答案: A B C (错误)

  ```
  一个空类默认会生成构造函数,拷贝构造函数,赋值操作符,析构函数
  一个类可以有多个析构函数
  类中析构函数可以为virtual,可以被重载
  类的构造函数如果都不是public访问属性,则类的实例无法创建
  ```

- 若串str="xunlei",其子串的数目是()

  # 正确答案: D  你的答案: C (错误)

  ```
  32
  31
  21
  22
  
  "software"中非空子串的个数就是8+7+....+1=36个。
  ```

- 假设磁盘上的物理块大小为512字节，一个逻辑记录长度为80个字符。若采用记录成组技术存储若干记录，当块因子为4时，磁盘空间的利用率可达到( )。

  # 正确答案: C  你的答案: D (错误)

  ```
  16%
  33%
  63%
  91%
  
  磁盘空间利用率的计算公式为：80*4/512=62.5%，约为63%。所以磁盘空间的利用率可达到63%。
  ```

- 对数据库第二范式的理解正确的是()

  # 正确答案: C  你的答案: D (错误)

  ```
  数据库表的每一列都是不可分割的原子数据项
  在1NF基础上,任何非主属性不依赖于其它非主属性
  在1NF基础上,非码属性必须完全依赖与码
  以上说法都不正确
  
  第一范式，原子性
  第二范式，没有包含在主键中的列必须完全依赖于主键，而不能只依赖于主键的一部分。
  第三范式， 不能存在传递依赖
  ```

- 假设以数组A[60]存放循环队列的元素,其头指针是front=47,当前队列有50个元素,则队列的尾指针值为()

  # 正确答案: B  你的答案: C (错误)

  ```
  3
  37
  97
  50
  ```

- 函数

  ```c++
  int f(unsigned int n)
  { 
     unsigned int m=0;
     for(m=0;n;++m)
     {
       n&=(n-1);
      }
      return m;
  }
  ```

  f(2486)的返回值是()

  # 正确答案: A  你的答案: A (正确)

  ```
  7
  10
  15
  1243
  
  n&=(n-1)相当于n=n&(n-1),执行一次也就相当于把二进制中的最低位的1置为0；循环执行，也就是计算2468的二进制中有多少个1.
  2486=2048 + 256 + 128 + 32 + 16 + 4 + 2 七个1
  ```

- 以下不是double compare(int,int)的重载函数的是()

  # 正确答案: D  你的答案: D (正确)

  ```
  int compare(double,double)
  double compare(double,double)
  double compare(double,int)
  int compare(int,int)
  
  
  a. 成员函数被重载的特征：
  
  （ 1 ）相同的范围（在同一个类中）；
  
  （ 2 ）函数名字相同；
  
  （ 3 ）参数不同；
  
  （ 4 ） virtual 关键字可有可无。
  
  b. 覆盖是指派生类函数覆盖基类函数，特征是：（重写）
  
  （ 1 ）不同的范围（分别位于派生类与基类）；
  
  （ 2 ）函数名字相同；
  
  （ 3 ）参数相同；
  
  （ 4 ）基类函数必须有 virtual 关键字。
  
  c.“ 隐藏 ” 是指派生类的函数屏蔽了与其同名的基类函数，规则如下：
  
  （ 1 ）如果派生类的函数与基类的函数同名，但是参数不同。此时，不论有无 virtual 关键字，基类的函数将被隐藏（注意别与重载混淆）。
  
  （ 2 ）如果派生类的函数与基类的函数同名，并且参数也相同，但是基类函数没有 virtual 关键字。此时，基类的函数被隐藏（注意别与覆盖混淆）
  ```

- 数据库DB,数据库系统DBS,数据库管理系统DBMS三者之间的关系是()

  # 正确答案: C  你的答案: A (错误)

  ```
  DBMS包括DB和DBS
  DBS就是DB,也就是DBMS
  DBS包括DB和DBMS
  DB包括DBS和DBMS
  
  数据库系统DBS由5部分组成：硬件系统、数据库集合、数据库管理系统及相关软件、数据库管理员和用户
  ```

- 索引字段值不唯一,应该选择的索引类型为()

  # 正确答案: A  你的答案: C (错误)

  ```
  普通索引
  候选索引
  主索引
  唯一索引
  
  索引类型分类：①主索引：主索引是一种只能在数据库表中建立不能在自由表中建立的索引。在指定的字段或表达式中，主索 引的关键字绝对不允许有重复值。②候选索引：和主索引类似，它的值也 不允许在指定的字段或表达式中重复。一个表中可以有多个 候选索引。③唯一索引：唯一索引允许关键字取重复的值。当有重复值 出现时，索引文件只保存重复值的第1次出现。提供唯一索引主要是为了兼容早期的 版本。④普通索引：普通索引允许关键字段有相同值。在一对 多关系的多方，可以使用普通索引
  ```

- 将长度为n的单链表连接在长度为m的单链表之后,其算法的时间复杂度为()

  # 正确答案: A  你的答案: B (错误)

  ```
  O(m)
  O(1)
  O(n)
  O(m+n)
  
  将长度为n的放在长度为m的链表之后，需要先遍历长度为m的链表，找到链表尾部，这个时间复杂度为O(m)，再将链表尾部的next指针指向长度为n的链表的头结点即可
  ```

- 下面说法正确的是()

  # 正确答案: A  你的答案: D (错误)

  ```
  一个空类默认一定生成构造函数,拷贝构造函数,赋值操作符,引用操作符,析构函数
  可以有多个析构函数
  析构函数可以为virtual,可以被重载
  类的构造函数如果都不是public访问属性,则类的实例无法创建
  ```

- 顺序表含有127个元素,向其插入一个新元素并保持原来顺序不变,平均要移动____个元素()

  # 正确答案: A  你的答案: C (错误)

  ```
  63.5
  8
  32
  7
  
  题意要保持原顺序不变的话，就只有两种情况，第一，插入在第一个位置，其余的向后移，总共127次；第二，插入到最后一个位置，其余的数不需要移动，总共0次；故而，平均移动次数为，(127+0)/2=63.5
  ```

- 下面程序的输出结果是

  ```c++
  char *p1= “123”, *p2 = “ABC”, str［50］= "xyz";
  strcpy（str+2,strcat（p1,p2））;
  cout << str;
  ```

  # 正确答案: D  你的答案: A (错误)

  ```
  xyz123ABC
  z123ABC
  xy123ABC
  出错
  
  分析：p1和p2指向的是常量存储区的字符串常量，没法连接，会有问题
  ```

- 下面函数的执行结果是输出

  ```c++
  char str[ ] = “xunlei”;
  char *p = str;
  int n = 10;
  printf(“%d, %d, %d/n”, sizeof(str), sizeof(p), sizeof(n));
  ```

  # 正确答案: B  你的答案: C (错误)

  ```
  4, 4, 4
  7, 4, 4
  6, 4, 4
  6, 6, 4
  
  在同一程序体内大小确实为7，包括'\0'；
  但是注意：
  在参数传递中，char str[ ] ="xunlei"; fun(str){cout<<sizeof(str)<<endl;}，结果就是4了，因为此时是一个指针。
  ```

- 现在有以下语句：

  ```c++
  struct _THUNDER{
         int iVersion;
         char cTag;
         char cAdv;
         int iUser;
         char cEnd;
  }Nowcoder;
  int sz = sizeof(Nowcoder);
  ```

  则执行后，变量sz的值将得到

  # 正确答案: D  你的答案: B (错误)

  ```
  11
  12
  13
  16
  
  分别 占字节数 int 4 char 1 char 1 int 4 char 1
  
  对齐方式   4  1  1  ②   4   1  ③
  
  圆圈的数代表补充的空字节
  对齐方式： 前面的长度必须为当前要添加的字符长度的整数倍，到最后还要补齐使得最终长度是最长的字符的整数倍
  ```

- a,b均为不等于0的整形变量，以下关系式恒成立的是：

  # 正确答案: C  你的答案: A (错误)

  ```
  a*b/a*b == 1
  a/b*b/a == 1
  a/b*b + a%b == a
  a/b*b == a
  
  a/b得到的是去除余数后的值，再加上a%b取摸的值就等于a了，
  ```

- 下列表达式中，不合法的是（）
  已知：double d = 3.2; int n = 3;

  # 正确答案: A D  你的答案: D (错误)

  ```
  d<<2;
  d/n
  !d && (n-3)
  (d-0.2)|n
  
  浮点数和位运算：所有的位运算都不能直接操作浮点数，这就是A和D错的原因，但是，我们可以间接对浮点数进行位运算，例如，将float数据，取地址(&)强行转化为整型(int等)指针后，再取值(*)后赋值给整型变量(int等)，然后就能对该变量进行位运算了。
  ```

- 关于内联函数正确的是（）

  # 正确答案: B  你的答案: D (错误)

  ```
  类的私有成员函数不能作为内联函数（可以）
  在所有类说明中内部定义的成员函数都是内联函数
  类的保护成员函数不能作为内联函数（可以）
  使用内联函数的地方会在运行阶段用内联函数体替换掉（编译阶段）
  ```

- 在使用浏览器打开一个网页的过程中，浏览器会使用的网络协议包括（）

  # 正确答案: A B C  你的答案: A B C (正确)

  ```
  DNS
  TCP
  HTTP
  Telnet
  
  思路：使用DNS去获得域名的主机ip，使用HTTP去获得报文交互，而HTTP是基于TCP协议的
  ```

- 下列表达式正确的是：

  # 正确答案: C  你的答案: C (正确)

  ```
  9++
  （x+y）++
  c+++c+++c++
  ++（a-b--）
  
  ++运算符的对象必须是左值，而表达式的值都是右值。
  区分左值与右值的最简单方式就是：左值可以对其取地址赋值，右值不可以取地址。
  ```

- 下面程序段的输出结果是：

  ```c++
  int a = 5, b = 4, c = 3, d = 2;
      if (a>b>c)
          printf("%d\n", d);
      else if ((c - 1 >= d) == 1)
          printf("%d\n", d + 1);
      else
          printf("%d\n", d + 1);
  ```

  # 正确答案: B  你的答案: D (错误)

  ```
  2
  3
  4
  编译错误
  
  a>b>c求的是一个逻辑值，正确为1，错误为0，a=5,b=4,c=3，首先a>b成立，逻辑值为1，而1小于2，故不输出2；
  +或者-的优先级高于>=；所以c-1>=d先减再判断，成立，为逻辑值1；（）优先级大于比较==，因为1=1，所以输出d+1；为3
  ```

- 有如下程序段，请问k的值是

  ```c++
  enum {
      a, b=5, c, d=4, e
  } k;
  k =c;
  ```

  # 正确答案: D  你的答案: C (错误)

  ```
  3
  4
  5
  6
  
  enum中：首元素不赋值的话，默认为0；后一个元素不赋值的话比前一个元素大1
  ```

- 用树形结构表示实体之间联系的模型是

  # 正确答案: C  你的答案: D (错误)

  ```
  关系模型
  网状模型
  层次模型
  以上三个都是
  
  层次模型是用树型结构记录的。树中每一个节点代表一个记录类型，树状结构表示实体型之间的联系
  ```

- 有如下程序段：

  ```c++
  char fun(char *);
  main()
  {
         char *s = “one”, a[5] = {0}, (*f1)(char *) = fun, ch;
  }
  ```

  则对函数fun的调用语句正确的是

  # 正确答案: C D  你的答案: 空 (错误)

  ```
  *f1(&a);
  f1（*s）;
  f1(&ch);
  ch = *f1(s);要改成（*f1）(s)才正确
  
  通过指针调用函数的两种形式：
  1、ret = (*p)();
  2、ret = p();
  对函数指针赋值的两种形式：
  1、pf = &func;
  2、pf = func；
  ```

- 下列关于虚函数的说法正确的是（）

  # 正确答案: C D  你的答案: C D (正确)

  ```
  在构造函数中调用类自己的虚函数，虚函数的动态绑定机制还会生效
  在析构函数中调用类自己的虚函数，虚函数的动态绑定机制还会生效
  静态函数不可以是虚函数
  虚函数可以声明为inline
  
  由于类的构造次序是由基类到派生类，所以在构造函数中调用虚函数，这个虚函数不会呈现出多态； 相反，类的析构是从派生类到基类，当调用继承层次中某一层次的类的析构函数时往往意味着其派生类部分已经析构掉，所以也不会呈现出多态
  ```

- 下面关于数组的描述错误的是：

  # 正确答案: C D  你的答案: A D (错误)

  ```
  在C++语言中一维数组的名字就是指向该数组第一个元素的指针
  长度为n的数组，下标的范围是0－n-1
  数组的大小必须在编译是确定
  数组只能通过值参数和引用参数两种方式传递给函数
  
  A.数组名字退化为指针，指向数组第一个元素，所以A正确
  B.长度为n的数组，下标从0开始计算一直到n-1，所以B正确
  C.数组大小是静态的，所以在运行时必须能确定，编译时不一定需要确定，所以C错误
  D.数组还可以通过数组指针传递给函数，所以D错误
  ```

- 下列关于const和#define定义常量的区别，说法不正确的有？

  # 正确答案: D  你的答案: C (错误)

  ```
  define宏是在预处理阶段展开。const常量是编译运行阶段使用
  宏没有类型，不做任何类型检查，仅仅是展开。const常量有具体的类型，在编译阶段会执行类型检查
  define宏仅仅是展开，有多少地方使用，就展开多少次，不会分配内存。const常量会在内存中分配(可以是堆中也可以是栈中)
  const定义和#define定义的常量在程序运行过程中只有一份拷贝
  
  A，正确，#define定义的宏是在预处理阶段进行替换的，const常量是在编译、运行阶段进行使用的。
  注意是仅仅的字符串替换，并不会检查其合法性。
  预处理阶段做了的任务：
  1:将头文件中的内容(源文件之外的文件)插入到源文件中
  2:进行了宏替换的过程（简单的字符串替换），定义和替换了由#define指令定义的符号
  3:删除掉注释的过程，注释是不会带入到编译阶段
  4:条件编译
  B，正确，所有的宏替换只是简单的字符串替换，注意是字符串替换，所以并不会检查其合法性，而const定义的常量依然是内置类型等，所以会对其进行类型安全检查。
  C，正确，宏定义在程序中使用了几次在预处理阶段就会被展开几次，并不会增加内存占用，但是宏定义每展开一次，代码的长度就要发生变化（所以有利必有弊啊！），而const常量也会为其分配内存（如果是动态申请空间肯定就是堆中了）。
  D，错误，const定义的常量只有一次拷贝没毛病，而define定义的变量在内存中并没有拷贝，因为所有的预处理指令都在预处理时进行了替换。
  ```

- 以下哪个值最大

  ```c++
  void test() {
  	int s1;
  	int s2;
  	int *s3 = (int *)malloc(4);
  	int *s4 = (int *)malloc(4);
  }
  ```

  # 正确答案: A  你的答案: 空 (错误)

  ```
  &amp;s1
  &amp;s2
  s3
  s4
  
  栈空间内存是从高地址向低地址值分配的，
  &amp属于HTML代码。表示符号  &
  &lt显示<，&gt显示>，&amp显示&，&quo显示"，&nbsp显示空格字符
  ```

- 699个节点的完全二叉树，有叶子节点多少个

  # 正确答案: A  你的答案: D (错误)

  ```
  350
  699
  1398
  其他都不是
  
  题目应该求得是最大叶子节点数
  先求得深度 k = 9
  再求最后一层叶子节点数和最少的根数 699-（512-1）=  188  ； 188/ 2 = 94
  再求倒数第二层的叶子节点数  256  - 94 = 162
  最后得结果  188 + 162 = 350；
  ```

- 以下哪个是带行缓冲的IO

  # 正确答案: C  你的答案: D (错误)

  ```
  write(STDOUT_FILENO, &quot;helloworld&quot;, 10);
  fprintf(stderr, &quot;helloworld&quot;);
  fwrite(&quot;helloworld&quot;, 10, 1, stdout);
  fo = fopen(&quot;a.txt&quot;, &quot;w&quot;); fwrite(&quot;helloworld&quot;, 10, 1, fo);
  
  缓冲区 分为三种类型：全缓冲、行缓冲和不带缓冲。 全缓冲 在这种情况下，当填满标准I/O缓存后才进行实际I/O操作。全缓冲的典型代表是对磁盘文件的读写。 行缓冲 在这种情况下，当在输入和输出中遇到换行符时，执行真正的I/O操作。这时，我们输入的字符先存放在缓冲区，等按下回车键换行时才进行实际的I/O操作。典型代表是标准输入(stdin)和标准输出(stdout)。 不带缓冲 也就是不进行缓冲，标准出错情况stderr是典型代表，这使得出错信息可以直接尽快地显示出来。
  
  fwrite和fread 是带缓冲的IO，read和write是不带缓冲的（系统调用是不带行缓冲）
  ```

- 父进程open了一个文件，并且通过fork产生一个子进程，以下说法正确的是

  # 正确答案: B  你的答案: A (错误)

  ```
  父子进程不共享文件的偏移量
  子进程复制了父进程的文件描述符表
  子进程复制了父进程的文件表
  子进程复制了父进程的v节点表
  
  fork产生的子进程是正在运行父进程的拷贝，也就说运行状态是一样的。对于文件操作是通过文件描述符来操作的（fd=open(filename,mode,flag),fd就是文件描述符），所以子进程复制的是文件描述符表
  ```

- 以下哪种POSIX锁效率最高

  # 正确答案: A  你的答案: B (错误)

  ```
  spin lock
  mutex lock
  r/w lock
  condition variable
  
  自旋锁（spin lock）：类似于互斥锁，但调用者的线程不会被挂起，而是一直处于忙等待的状态，因此效率远高于互斥锁。
  ```

- 在基类中，关于访问标号以下描述错误的是

  # 正确答案: B D  你的答案: A B (错误)

  ```
  protected成员不可以被类的调用方访问
  private成员不可以被类的调用方和友元访问
  public成员可以被派生类访问
  protected成员可以被类的调用方和友元访问
  
  B选项错误了，友元访问权限跟本类一致，什么属性都可以访问。
  但是这里A,D选项矛盾了，protected可以被1本类中的函数、2.子类的函数、3.其友元函数访问。
  但不能被该类的对象访问
  ```

- 这段代码执行后的输出结果是：
  char *str = “Thunder Network”;
  str[0] = ‘\0’;
  printf(“%s\n”, str);

  # 正确答案: D  你的答案: A (错误)

  ```
  空
  “Thunder Network”
  代码编译错误
  段错误
  
  不能修改常量
  ```

- 下列选项中是操作系统死锁的必要条件的有哪些？

  # 正确答案: A D  你的答案: A B C D (错误)

  ```
  互斥条件
  系统资源有限
  进程调度上不合理
  环路等待条件
  
  死锁产生的四个必要条件
  互斥条件：资源是独占的且排他使用，进程互斥使用资源，即任意时刻一个资源只能给一个进程使用，其他进程若申请一个资源，而该资源被另一进程占有时，则申请者等待直到资源被占有者释放。
  不可剥夺条件：进程所获得的资源在未使用完毕之前，不被其他进程强行剥夺，而只能由获得该资源的进程资源释放。
  请求和保持条件：进程每次申请它所需要的一部分资源，在申请新的资源的同时，继续占用已分配到的资源。
  循环等待条件：在发生死锁时必然存在一个进程等待队列{P1,P2,…,Pn},其中P1等待P2占有的资源，P2等待P3占有的资源，…，Pn等待P1占有的资源，形成一个进程等待环路，环路中每一个进程所占有的资源同时被另一个申请，也就是前一个进程占有后一个进程所深情地资源。
  以上给出了导致死锁的四个必要条件，只要系统发生死锁则以上四个条件至少有一个成立。事实上循环等待的成立蕴含了前三个条件的成立，似乎没有必要列出然而考虑这些条件对死锁的预防是有利的，因为可以通过破坏四个条件中的任何一个来预防死锁的发生。
  ```

- 编译过程中，语法分析器的任务是？

  # 正确答案: B C D  你的答案: A B C (错误)

  ```
  分析单词是怎样构成的
  分析单词串是如何构成语言和说明的
  分析语句和说明是如何构成程序的
  分析程序的结构
  ```

- 下列运算符中，在C++语言中不能重载的是：

  # 正确答案: C  你的答案: C (正确)

  ```
  *
  >=
  ::
  delete
  
  记住只要挂'.'的运算符均不能被重载
  C++不能重载的总共五个：
  （1） "."（类成员访问运算符） 
  （2）" .*"（类成员指针访问运算符） 
  （3） "::"（域运算符） 
  （4）"siezof"（长度运算符） 
  （5） " ?:"（条件运算符）
  ```

- 下面关于多态性的描述，错误的是：

  # 正确答案: C  你的答案: C (正确)

  ```
  C++语言的多态性分为编译时的多态性和运行时的多态性
  编译时的多态性可通过函数重载实现
  运行时的多态性可通过模板和虚函数实现
  实现运行时多态性的机制称为动态绑定
  
  C，运行时多态通过虚函数实现，就是运行时根据对象类型自动选择正确的调用接口。模板属于编译时多态性，因为编译时自动根据模板生成模板函数。
  ```

- 引用标准库时，下面的说法你认为哪个是正确的：

  # 正确答案: B  你的答案: C (错误)

  ```
  语句#include “stdlib.h”是正确的，而且程序编译速度比#include <stdlib.h>要快
  语句#include <stdlib.h>是正确的，而且程序编译速度比#include “stdlib.h”要快
  语句#include <stdlib.h>和#include “stdlib.h”都是正确的，程序编译速度没有区别
  语句#include “stdlib.h”是错误的
  
  #inlcude <> 首先 只搜索系统目录,不会搜索本地目录.比如你自己写一个头文件,你用#include <>会出错.  
  #inlude ""首先搜索本地目录,如果本地目录没有才会搜索系统目录.
  可以把系统的文件 放到当前目录下 改成 ""   可以优先使用
  所以B是对的
  ```

- 设a、b、c、d、m、n均为int型变量，且a=5、b=6、c=7、d=8、m=2、n=2,则逻辑表达式（m=a>b）&&(n=c>d)运算后，n的值为：

  # 正确答案: C  你的答案: A (错误)

  ```
  0
  1
  2
  7
  
  m=a>b后m=0，表达式为假，&&后半部分不会操作，因此n为初始值2
  ```

- 建立派生类对象时,3种构造函数分别是a(基类的构造函数)、b(成员对象的构造函数)、c(派生类的构造函数)这3种构造函数的调用顺序为: 

  # 正确答案: A  你的答案: B (错误)

  ```
  abc
  acb
  cab
  cba
  
  A 在继承中派生类的对象调用构造函数的顺序，应该是先调用基类的构造函数，然后是成员中的对象对应类的构造函数，最后是派生类自己的构造函数.
  ```

- 如果友元函数重载一个运算符时，其参数表中没有任何参数则说明该运算符是：

  # 正确答案: D  你的答案: A (错误)

  ```
  一元运算符
  二元运算符
  选项A）和选项B）都可能
  重载错误
  
  友元函数重载时,参数列表为1,说明是1元,为2说明是2元
  成员函数重载时,参数列表为空,是一元,参数列表是1,为2元
  ```

- 输出结果是

```c++
#define F(X,Y)   (X)--, (Y)++, (X)*(Y);
…
int i, a = 3, b = 4;
for( i = 0; i<5; i++)
    F(a,b) ;
printf(“%d, %d”, a, b);
```

 正确答案: D  你的答案: 空 (错误)

```
3, 4
3, 5
-2, 5
-2, 9

宏定义只是替换，这里要和函数传值调用区分开，不能搞混了。
使用宏定义F(x,y) -> #define F(X,Y)   (X)--, (Y)++, (X)*(Y)
展开后如下：
inti, a = 3, b = 4;
for( i = 0; i<5; i++)
    (a)--,(b)++,(a)*(b);
printf(“%d, %d”, a, b);
(a)--,(b)++,(a)*(b);
是逗号表达式，按从左往右逐个计算表达式，整个表达式最终结果(a)*(b)的值（这部分对a和b值无影响）
计算 了5次for循环的（a)--和(b)++ 的到a=-2，b = 9；
```

- 已知一段文本有1382个字符，使用了1382个字节进行存储，这段文本全部是由a、b、c、d、e这5个字符组成，a出现了354次，b出现了483次，c出现了227次，d出现了96次，e出现了232次，对这5个字符使用哈夫曼（Huffman）算法进行编码，则以下哪些说法正确（）

  # 正确答案: A C D  你的答案: A B D (错误)

  ```
  使用哈夫曼算法编码后，用编码值来存储这段文本将花费最少的存储空间
  使用哈夫曼算法进行编码，a、b、c、d、e这5个字符对应的编码值是唯一确定的
  使用哈夫曼算法进行编码，a、b、c、d、e这5个字符对应的编码值可以有多套，但每个字符编码的位（bit）数是确定的
  b这个字符的哈夫曼编码值位数应该最短，d这个字符的哈夫曼编码值位数应该最长
  
  A正确，Huffman树就是求最优解。可以有多套方案，但最终每套方案生成的编码长度都相同且都是最优解。
  B错误，我们可以将左子树定为1右子树定为0也可以反之，不同的方案获得的编码值是不同的，但每个字符的编码长度是固定的。
  C正确，不同的方案影响的只是通向节点的路径为0还是1，而不会影响Huffman树的层次结构
  D正确，生成了Huffman树之后，我们就能看到，出现频率越高的节点越靠近根，深度越小即编码值尾数越短；出现频率越低的节点越远离根，深度越大即编码位数越长。
  ```











#### 面经

1.new delete和malloc free的区别 、new出来的对象可以用free吗？ malloc出来的东西可以用delete吗？ 

4.虚函数底层（虚函数表怎么调用）？ 

5.class A{ 

  virtual void show(); 

  }； 

  class B:public A{ 

  void show(); 

  }; 

  A* a = new B; 

  a->show(); 

  调用哪个show函数？ 

  6.析构函数为什么要声明为virtual？ 

  7.B* b = new B; 

  delete b会不会运行类A的析构函数？ 

  8.public privite protected继承的区别？ 

  9.class A 

  { 

​    virtual void show(); 


  }; 

  class B:private C{ 

  void run(){ 

  show(); 

  } 

  };能不能正常的编译运行？ 

  10.在构造函数里面能调用虚函数吗？析构函数里面能调用虚函数吗？ 

  11.继承层次里面，先调用父类的构造函数还是先调用子类的？ 析构？ 

  12.C++中vector和list插入删除情况下迭代器失效情况？ 

  13.vector扩容？ 

#####   14.n个元素依次插入vector、map的时间复杂度？ 

- 问题： 将N个元素使用push_back插入到vector中， 求push_back操作的复杂度。


  简单分析如下：

  ```c++
  考虑vector每次内存扩充两倍的情况。
  
  如果我们插入N个元素， 则会引发lgN次的内存扩充，而每次扩充引起的元素拷贝次数为
  
                                    2^0,  2^1, 2^2, ..., 2^lgN.
  
  把所有的拷贝次数相加得到
  
                  2^0 + 2^1 + 2^2 + ... + 2^lgN = 2 * 2^lgN - 1 约为 2N次
  
  共拷贝了N次最后一个元素， 所以总的操作大概为3N
  
  所以， 每个push_back操作分摊3次， 是O(1) 的复杂度。
  ===========================================
  map insert
  复杂度
  如果插入单个元素且无暗示，时间复杂度为 O(logn)，其中 n 为容器的大小。
  
  如果插入单个元素且有最优位置（Position）暗示，时间复杂度为 O(1)，这是一个平均分摊后的常值（Amortized constant）。
  
  如果插入多个元素，时间复杂度为 O(nlogn)，“第一个” n 为插入元素数，“第二个” n 为插入元素数加容器大小。如果插入的范围中的元素已经按同样的排序规则排序，执行过程将被优化，时间复杂度甚至会降到 O(n)。
  
  迭代器有效性
  不会改变。
  
  ```

#####  16.无序n个元素数组，最快找出前k个最小元素？ 【⭐】【有编程题】

- 使用快排思想O(n),但会修改原数组，

- 使用优先级队列O(1)获取最大值，O(logk)完成插入删除操作

- 使用set或multiset（红黑树），O(logk)完成查找、插入、删除操作

##### 17.创建堆的时间复杂度？ https://blog.csdn.net/RunningBeef/article/details/108752281

- 两种方式

```c++
（1）自顶向下的建堆方式

这种建堆的方法具有O(n*log2n)的时间复杂度。从根结点开始，然后一个一个的把结点插入堆中。当把一个新的结点插入堆中时，需要对结点进行调整，以保证插入结点后的堆依然是大根堆。如下图所示，是采用自顶向下的方法建立的大根堆。

 

其中h = log2(n+1)-1，第k层结点个数为2k个(当然最后一层结点个数可能小于2h)。第k层的一个结点插入之后需要进行的比较(移动)次数为k。于是总的比较(移动)次数为∑k*2k(k = 0,1,2,...,h)。可以求得∑k*2k(k = 0,1,2,...,h)=(log2(n+1)-2)*(n+1)+2 = O(n*log2n)

 

（2）自下向上的建堆方式

这种建堆的方法具有O(n)的时间复杂度。如下图所示，从第一个非叶子结点开始进行判断该子树是否满足堆的性质。如果满足就继续判断下一个点。否则，如果子树里面某个子结点有最大元素，则交换他们，并依次递归判断其子树是否仍满足堆性质。

 
因为调整根结点以及其左右孩子的位置的复杂度是O(1),再加上对其子树的递归判断是否满足堆性质需O(h),而在任意高度h上，至多有[n/2^(h+1)]个结点。则总共的时间复杂度为∑h*(n)/(2(h+1)).根据调和级数的积分公式可得，时间复杂度为O(n)。
```

#####   18.TCP三次握手？ 

#####   19.TIME_WAIT？ 

#####   20.accept在三次握手哪个阶段？ 

- 18、19、20  画了图，看图回答

  21.滑动窗口  发送窗口 区别？ 

-  滑动窗口（发送窗口和接收窗口）

  - TCP的滑动窗口主要有两个作用，一是提供TCP的可靠性，二是提供TCP的流控特性。同时滑动窗口机制还体现了TCP面向字节流的设计思路。

  -  发送窗口与接收窗口关系

    TCP是双工的协议，**会话的双方都可以同时接收、发送数据**。TCP会话的**双方都各自维护一个“发送窗口”和一个“接收窗口”**。其中**各自的“接收窗口”大小取决于应用、系统、硬件的限制**（TCP传输速率不能大于应用的数据处理速率）。**各自的“发送窗口”则要求取决于对端通告的“接收窗口”，要求相同**。

##### 22.流量控制 拥塞控制的区别？ 

  - 流量控制是端到端的控制，例如A通过网络给B发数据，A发送的太快导致B没法接收(B缓冲窗口过小或者处理过慢)，这时候的控制就是流量控制，原理是通过滑动窗口的大小改变来实现。 
    拥塞控制是A与B之间的网络发生堵塞导致传输过慢或者丢包，来不及传输。防止过多的数据注入到网络中，这样可以使网络中的路由器或链路不至于过载。拥塞控制是一个全局性的过程，涉及到所有的主机、路由器，以及与降低网络性能有关的所有因素。

#####   23.滑动窗口在哪个端？ 

<img src="C:\Users\10690\AppData\Roaming\Typora\typora-user-images\image-20210924184242300.png" alt="image-20210924184242300" style="zoom:50%;" />

#####   25.[客户端]()有几个线程？ （项目中）

#####   26.epoll LT ET区别？

epoll提供两种工作模式：LT 和 ET。

**LT模式是epoll默认的工作方式**，相当于一个**效率很高的poll模型**；而ET是**高效**的工作方式。

LT 和 ET本质的区别是：

| lt   | 当检测到epoll_wait 上有就绪事件的时候，可以不立即执行，当下次再次调用epoll_wait时还会提醒 |
| ---- | ------------------------------------------------------------ |
| et   | 当检测到epoll_wait 上有就绪的事件的时候，就必须处理该事件，否则下次调用epoll_wait 的时候，也不会提醒。 |

客户端向服务器发送数据，
lt 模式下，如果服务端一次没有将全部的数据读完，则epoll_wait 会再次提醒，直到把所有的数据全部读完为止
et 模式下，如果未将全部的数据读完，则epoll_wait 不再提醒，剩余的数据还在接收方的接收缓冲区中。

netstat -napt 可以查看接收缓冲区的内容

ET在很大程度上减少了epoll事件被重复触发的次数，效率较高，因此，在使用ET模式时，必须使用非阻塞的接口，以避免由于一个文件描述符的读或写阻塞操作把处理多个文件描述符的任务饿死（当接受数据缓冲区比较小时，需要循环接受数据）



##### 27.什么是gcc / g++

首先说明：gcc 和 GCC 是两个不同的东西

GCC:GNU Compiler Collection(GUN 编译器集合)，它可以编译C、C++、JAV、Fortran、Pascal、Object-C、Ada等语言。

gcc是GCC中的GUN C Compiler（C 编译器）

g++是GCC中的GUN C++ Compiler（C++编译器）

一个有趣的事实就是，就本质而言，gcc和g++并不是编译器，也不是编译器的集合，它们只是一种驱动器，根据参数中要编译的文件的类型，调用对应的GUN编译器而已，比如，用gcc编译一个c文件的话，会有以下几个步骤：

Step1：Call a preprocessor, like cpp.

Step2：Call an actual compiler, like cc or cc1.

Step3：Call an assembler, like as.

Step4：Call a linker, like ld

由于编译器是可以更换的，所以gcc不仅仅可以编译C文件

所以，更准确的说法是：gcc调用了C compiler，而g++调用了C++ compiler

gcc和g++的主要区别

1. 对于 *.c和*.cpp文件，gcc分别当做c和cpp文件编译（c和cpp的语法强度是不一样的）

2. 对于 *.c和*.cpp文件，g++则统一当做cpp文件编译

3. 使用g++编译文件时，**g++会自动链接标准库STL，而gcc不会自动链接STL**

4. gcc在编译C文件时，可使用的预定义宏是比较少的

5. gcc在编译cpp文件时/g++在编译c文件和cpp文件时（这时候gcc和g++调用的都是cpp文件的编译器），会加入一些额外的宏，这些宏如下：

\#define __GXX_WEAK__ 1
\#define __cplusplus 1
\#define __DEPRECATED 1
\#define __GNUG__ 4
\#define __EXCEPTIONS 1
\#define __private_extern__ extern

6. 在用gcc编译c++文件时，为了能够使用STL，需要加参数 –lstdc++ ，但这并不代表 gcc –lstdc++ 和 g++等价，它们的区别不仅仅是这个

主要参数

-g - turn on debugging (so GDB gives morefriendly output)

-Wall - turns on most warnings

-O or -O2 - turn on optimizations

-o - name of the output file

-c - output an object file (.o)

-I - specify an includedirectory

-L - specify a libdirectory

-l - link with librarylib.a

使用示例：g++ -ohelloworld -I/homes/me/randomplace/include helloworld.C









### 沐瞳科技

#### 简答题

- vector和list的区别及应用场景；vector.push_back迭代器失效问题

- map和unordered_map的区别；insert和[]的区别

- inline函数的作用
- 一个任务可以使用多线程或多进程完成，两者的区别是什么
- 该段代码从大文件中读取多行长字符串，经过多次拷贝进入其他线程，如何修改代码使得拷贝次数尽量少？不要使用裸指针

```c++
string buf;
ifstream ifs("input.txt");
vector<string> bufs;
while (getline(ifs, buf))
{
    bufs.push_back(buf);
}
auto th1 = new thread([bufs]() {
    //read bufs
});

```

- 尝试写一段代码模拟生产者、消费者模型，要求并发（注意线程安全）

```c++
#include <iostream>
#include <thread>
#include <mutex>
#include <condition_variable>
#include <queue>

using namespace std;

namespace wd
{
mutex myMutex;
condition_variable cv;
bool flag = false;
bool notify = false;
queue<int> products;//任务队列

void Producer()
{
    int count = 0;
    while (count < 5) {//生产5件
        unique_lock<mutex> lk(myMutex);
        while (notify || !products.empty()) {
            cv.wait(lk);
        }
        products.push(count);
        notify = true;
        cv.notify_one();
        count++;
    }
    flag = true;
    cv.notify_one();//通知消费者不产了
}

void Comsumer()
{
    while (!flag) {
        unique_lock<mutex> lk(myMutex);
        while (!notify) {
            cv.wait(lk);
        }
        while (!products.empty()) {
            products.pop();
            notify = false;
            cv.notify_one();
        }
    }
}

}

void test()
{
    thread th1(wd::Producer);
    thread th2(wd::Comsumer);

    th1.join();
    th2.join();
}

int main()
{
    test();
    cout << "done" << endl;
    return 0;
}
```

#### 编程题

- 反转链表

```c++
ListNode* reverseList(ListNode* pHead){
        if(pHead == nullptr){
            return nullptr;
        }
        ListNode* pCur = pHead;
        ListNode* pPre = nullptr;
        ListNode* pRear = pHead->next;

        while(pRear){
            pCur->next = pPre;

            pPre = pCur;
            pCur = pRear;
            pRear = pRear->next;

        }
        pCur->next = pPre;
        return pCur;
    }
```

- 青蛙跳台阶（可以跳1，2，3）

```c++
class Solution{
public:

    int getJumps(const int &n){
        if(0 == n){
            return 0;
        }
        vector<int> vec = {1, 2, 3};
        backTacking(vec, 0, n);
        return _results.size();
    }
    void backTacking(vector<int> vec, int sum, int n){
        if(sum == n){
            _results.push_back(_result);
        }

        for(int start = 0; start < (int)vec.size(); ++ start){
            if(sum + vec[start] > n){
                continue;
            }
            _result.push_back(vec[start]);
            sum += vec[start];
            backTacking(vec, sum, n);
            _result.pop_back();
            sum -= vec[start];
        }
    }
private:
    list<vector<int>> _results;
    vector<int> _result;
};
```





