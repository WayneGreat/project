

# 项目

## 文件管理系统

### 1、流程

服务器客户端搭建连接 -> 注册登录 -> 用户表、虚拟文件表 -> MD5文件名、断点续传、零拷贝大文件传输

### 2、负责的部分

- 登录注册模块：

  - 用户表

  <img src="C:\Users\10690\AppData\Roaming\Typora\typora-user-images\image-20210917134942918.png" alt="image-20210917134942918" style="zoom:50%;" />

  - 服务器先传输 salt 值（从用户表中查找）给客户端， 客户端 crypt 加密后， 传输密码密文给服务器， 服务器进行匹配后， 判断是否成功（登录）
  - 服务器判断用户名，生成新的salt值保存到用户表，发送给客户端，客户端输入密码与salt值加密后，传输密文给服务器保存（注册）

  - salt的随机生成

  ```c
  #define STR_LEN 10 //定义随机输出的字符串长度。
  char *GenerateStr() {
  char str[STR_LEN + 1] = {0};
  int i,flag;
  srand(time(NULL));
  for(i = 0; i < STR_LEN; i ++) {
  flag = rand()%3;
  switch(flag) {
  case 0: str[i] = rand()%26 + 'a'; break;
  case 1: str[i] = rand()%26 + 'A'; break;
  case 2: str[i] = rand()%10 + '0'; break;
  }
  } p
  rintf("%s\n", str);//输出生成的随机数。
  return str;
  }
  ```

  - crypt函数 -> crypt(passwd,salt)  

  ```
  crypt 为支持不同的方式将 salt 格式化为
  $id$salt$encode
  其中 id 代表不同的算法
  1  | MD5
  2a | Blowfish (not in mainline glibc; added in some
     | Linux distributions)
  5  | SHA-256 (since glibc 2.7)
  6  | SHA-512 (since glibc 2.7) 当前我们 Linux 采用的加密算法
  这样我们就可以利用 crypt 函数将用户输入的字符加密， 然后与密码文件中的密码进行对比
  
  返回一个 $6$qOrvsN41$gGlv8z7P1sAKuyaTAY03AvCn9/Z6Ygc4DJ9Uwe0RVzNAI6TQsTfsdihPnIh3lSZ
  V2C02HjW.9bvJNdep3k.ER. 字符串
  
  可以看到这里的 salt 为 $6$qOrvsN41  
  ```

- 虚拟文件表

<img src="C:\Users\10690\AppData\Roaming\Typora\typora-user-images\image-20210917135010197.png" alt="image-20210917135010197" style="zoom:50%;" />

```
服务器： 由数据库记录每一个用户的目录结构和文件， 但每个文件的内容本身存储在服务器
磁盘上， 并以 MD5 码进行命名。 所有用户上传的文件都存在服务器上的某一个目录里， 如
/netdisk/

客户端： 在客户端， 用户登录服务器后， 每个用户只能看到自己的文件， 不能看到其他人的
文件。 然后可以执行各种操作命令， 包括查看文件信息， 上传文件， 下载文件， 删除文件，
创建文件夹等。  
```

- MD5码的生成：[Linux下C语言计算文件的md5值（长度32）](https://blog.csdn.net/a_ran/article/details/40897159) -> 文件命名 -> 文件秒传功能

- 断点续传功能

  ```
  断点续传： 该功能支持从文件上次中断的地方开始传送数据， 而并非是从文件开头传送。
  举例： 进行 gets hello.avi 时候， 首先判断本地是否存在 hello.avi
  如果存在， 则通过 stat 函数获取本地文件 hello.avi 的大小， 然后传递给服务器的是
  gets hello.avi 1000
  如果不存在， 则直接进行下载即可。
  ```

- 零拷贝技术：
  - mmap 将大文件映射入内存， 进行网络传递。 当发现文件大于 100M， 就使用 mmap 方式映
    射该文件， 然后再传输。  

### 3、遇到的问题及解决

- 虚拟文件表的设计
  - 客户端登录后， 直接获取服务器的目录结构， 但只能针对单个用户有效， 如果是多用户后， 就不能这样去实现了。
  -  因为当有多用户时， 每个用户只能看到自己上传的文件， 而看不到其他用户的文件， 这说明每个用户需要拥有自己独立的目录结构。 **目录结构设计、 用数据库存储**

## 搜索引擎【⭐】

### 1、流程

服务器客户端搭建连接 -> 建立词典库，网页库，倒排索引库 -> 关键字查询与候选词推荐、图书网页查询推荐

### 2、负责的部分

- 离线部分 - 词典库及索引文件、网页库及索引文件（非去重）
  - 输入语料文件（xml文件【图书信息】）、停用词文件（去除中文停用词）
  - 将xml文件的信息中每一页网页信息保存到（webpage）一个类中，存储到vector中
  - 使用cppjieba库进行网页内容的中文分词（utf-8编码的文件）
  - 使用map<词，词频>（映射）保存词语、词频
  - 格式化输出到词典库文件，并且建立索引文件（单个汉字，词典文件的行数-1）
  - 使用simhash算法将保存在vector中网页内容进行去重，

  <img src="C:\Users\10690\AppData\Roaming\Typora\typora-user-images\image-20210920121228155.png" alt="image-20210920121228155" style="zoom:50%;" />

  - 算法过程大概如下：

      1. 将Doc进行关键词抽取(其中包括分词和计算权重)，抽取出n个(关键词，权重)对， 即图中的`(feature, weight)`们。 记为 `feature_weight_pairs` = [fw1, fw2 … fwn]`，其中 fwn = (`feature_n`,`weight_n`)。
      2. `hash_weight_pairs` = [ (hash(feature), weight) for feature, weight in `feature_weight_pairs` ] 生成图中的`(hash,weight)`们, 此时假设hash生成的位数`bits_count = 6`（如图）;
      3. 然后对 `hash_weight_pairs` 进行位的纵向累加，如果该位是1，则`+weight`,如果是0，则`-weight`，最后生成`bits_count`个数字，如图所示是`[13, 108, -22, -5, -32, 55]`, 这里产生的值和hash函数所用的算法相关。
      4. `[13,108,-22,-5,-32,55] -> 110001`这个就很简单啦，正1负0。
      5. 接着使用汉明距离计算两个二进制xor后的二进制中1的个数

  ```c++
  A = 100111;
  B = 101010;
  hamming_distance(A, B) = count_1(A xor B) = count_1(001101) = 3;（异或 ^）
  
  bool isEqual(uint64_t lhs, uint64_t rhs, unsigned short n = 3)
      //1的个数小于3说明两篇文章一致
  {
      unsigned short cnt = 0;
      lhs ^= rhs;
      while(lhs && cnt <= n)
      {
          lhs &= lhs - 1;
          cnt++;
      }
      if(cnt <= n)
      {
          return true;
      }
      return false;
  }
  ```

  - 格式化输出vector中的网页信息到网页库，并使用unoredred_map<网页id，<网页头距离文件开头的偏移量，网页长度>>记录，再输出网页索引库
  - 遍历vector中的网页内容，每一篇进行词频统计（词，网页id，该词在这篇网页中出现的次数 tf ）
  - 通过TF-IDF算法计算该词在所有网页中的出现的次数df，该词在该网页中的重要性（逆文档频率）idf，网页库中网页的总数N，得到词语在该网页的权重w，再归一化处理（该词权重w/该网页其他词的权重）

  <img src="C:\Users\10690\AppData\Roaming\Typora\typora-user-images\image-20210920122449883.png" alt="image-20210920122449883" style="zoom: 67%;" />

  - 将用unordered_map<词语，set<< 网页id，归一化后的权重w' >>>保存并输出到倒排索引库文件中

- 在线部分 - 关键词查询、网页查询
  - 获取到客户端传递过来的查询词之后， 再从索引之中查找与之相近的候选词， 选取到最合适的候选词之后再将其发送给客户端。
  
  - 使用cppjieba库进行查询词的分词
  
  - o1时间从词典中找到一系列的词语
  
  - 使用最小编辑距离计算这一系列的词语与查询词的相似度，将其放入到优先级队列中
  
  - 优先级比较顺序：1、最小距离 2、词频 3、按字母表顺序比较候选词
  
  - 返回相关性最好的候选词列表给用户，实现推荐功能（双方使用json格式进行数据传输）
  
  - 对查询过的关键字信息采用lru缓存，优化查询体验（每个工作线程对应一个cache，避免缓存共享时的等待；还有每隔一段时间需要将所有cache进行更新同步）
  
    - cache实现：
  
      - 每个工作线程对应一个cache，采用LRU算法的淘汰策略
  
      <img src="C:\Users\10690\AppData\Roaming\Typora\typora-user-images\image-20210920123410145.png" alt="image-20210920123410145" style="zoom: 80%;" />
  
      - 缓存的更新（只更新需要更新的数据）
  
      ![image-20210920123557989](C:\Users\10690\AppData\Roaming\Typora\typora-user-images\image-20210920123557989.png)
  
      - 当更新cache时，有查询需求的处理时的处理
  
      ![image-20210920123913711](C:\Users\10690\AppData\Roaming\Typora\typora-user-images\image-20210920123913711.png)
  
  - 查询策略：
    （1） 在处理查询请求时， **对于查询的关键词， 将它们视为一篇文档 X， 通过**
    **TF-IDF 算法计算出每个关键词的权重系数； 将其组成一个向量(x1, x2, ...,xn)，**
    **该向量作为基准向量 Base**， 在下面的(3)中使用；
    （2） 通过**倒排索引表去查找包含所有关键字的网页**； 只要其中有一个查询词不
    在索引表中， 就认为没有找到相关的网页；
    （3） 如果找到了网页， 则需要对查找到的网页进行排序。 排序算法采用余弦相
    似度。 既然查找到的网页都包含查询词， 那么**获取每个查询词的 w**， **将它们组**
    **成一个向量 Y = (y1,y2, ... yn)， 用该向量代表这篇网页**， 该向量 Y 是网页的特征，
    然后**计算它与 Base 的余弦值**， 该**余弦值代表的就是 Y 与 X 的相似度**； 那么现
    在只需要将**查找到的所有网页都与 X 进行余弦相似度 cosθ的计算**， 然后**根据**
    **cosθ的大小进行排序， cosθ越大越相似， 这样的网页应该出现在前排的位置。**
    cosθ的计算方法如下：
    X * Y = (x1 * y1 + x2 * y2 + x3 * y3)
    cosθ = (X * Y) / (|X| * |Y|)
    （4） 当**找到网页之后**， 还需要**提取每篇网页中的图书标题和摘要信息**， 然后**将这些**
    **信息封装成一个 JSON 字符串， 交给服务器框架模块去发送给客户端**。 要注意的是： 摘要信息是根据查询词自动生成的。  

<img src="C:\Users\10690\AppData\Roaming\Typora\typora-user-images\image-20210917164903652.png" alt="image-20210917164903652" style="zoom:50%;" />

- Recator模型：

  - 服务端的准备：

    - 读取配置文件，通过配置文件获取词典及网页
    - socket的fd、bind、listen
    - 线程池的构造
    - 使用function和bind组合注册回调函数
    - 使用epoll监听循环监听文件描述符（listenfd、newfd、eventfd【用于线程通知事件完成后的发送】）
  - 客户端与服务端连接查询：
      - listenfd就绪处理connect，newfd就绪处理发过来的消息-》将任务放入到任务队列中，子线程从任务队列中获取任务进行处理，eventfd用于事件通知发送
      - 子线程对字符串进行分词，在倒排索引表中查询，在计算最小编辑距离返回优先级最高的若干个候选词，计算每个值的权重，使用余弦相似度算法用于网页相关度的排序，返回json格式图书信息
      - 将信息加入到一个临界资源中（用vector保存多个子线程处理好的需要返回给不同客户端的json消息），后唤醒eventfd，就绪后主线程开始从临界资源中（vector）获取json数据发送给对应的客户端，处理与发送的模块分离提高线程池的效率
      - Reactor + Threadpool 的模型

  <img src="C:\Users\10690\AppData\Roaming\Typora\typora-user-images\image-20210920110950203.png" alt="image-20210920110950203" style="zoom:67%;" />
  
  - 线程数量的问题：
    - 在设计时首先要确定我们应用程序的类型，是计算密集型还是I/O密集型，
    - 如果是**计算密集型应用，那么我们设计线程的数量应该等同于我们所能使用的CPU内核数**，
    - 反之，**如果是I/O密集型应用，我们可以设置远大于可以CPU内核数的线程数来提高性能（一般为内核数 的两倍）。**

### 3、遇到的问题及解决

使用第三方库时，如cppjieba与simhash时会冲突

**lru缓存只弄一个的时候，线程需要互斥访问缓存， 用户搜索的效率不高，因此换成每个线程维护一个cache，每隔一段时间更新cache，保持一致，用空间换时间，提高效率**

### 4、项目的提升

lru缓存设计（亮点，优化）

## GDB调试【⭐】

https://cxybb.com/article/wyc7610/108643677

- 在编译时或在makefile中添加 -g选项（补充调试信息）
- g++ test.c -o test -g
- gdb test
  - list / l : 列出代码
  - run / r : 执行程序
  - break / b : 打断点
  - continue / c : 继续运行
  - next / n : 下一步（单步调试，不进入函数）
  - step / s : 下一步（进入函数）
  - info break / i b : 显示断点信息
  - delete 编号 : 删除某个断点
  - disable / enbale  编号 : 失效/生效某个断点
  - ignore 编号  ：令指令编号失效若干次
  - print / p 表达式 : 打印变量
  - backtrace / bt : 看堆栈
  - display 表达式 ：看执行的信息
  - info display : 获取编号
  - undisplay  编号 : 
  - h 命令名【查命令】
  - x/3xw arr 看内存
- gdb调试错误操作：
  - -g选项编译
  - 解除core文件大小的限制
    - ulimit -c unlimited
  - 执行程序
  - 使用gdb检查core文件
    - gdb xxx(可执行程序) core 【看错误】

