# 必会排序算法【⭐】

<img src="O:\Downloads\QQ截图20210523161010.png" alt="QQ截图20210523161010" style="zoom: 50%;" />

### 1、冒泡(On,On^2;O1)【稳】、插入(On,On^2;O1)【稳】、选择(On^2;O1)

- 冒泡算法思想
  - 比较相邻的元素。如果第一个比第二个大，就交换他们两个。
  - 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。
  - 针对所有的元素重复以上的步骤，除了最后一个。
  - 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。
- 插入算法思想
  - 从第一个元素开始，该元素可以认为已经被排序
  - 取出下一个元素，在已经排序的元素序列中从后向前扫描
  - 如果该元素（已排序）大于新元素，将该元素移到下一位置
  - 重复步骤3，直到找到已排序的元素小于或者等于新元素的位置
  - 将新元素插入到该位置后
  - 重复步骤2~5
- 选择算法思想：
  - 在未排序序列中找到最小（大）元素，存放到排序序列的起始位置
  - 从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾
  - 以此类推，直到所有元素均排序完毕

```c++
void BubbleSort(vector<int>& nums)
{
    int len = nums.size();
    bool flag = false;//false表示在一趟中没有进行交换

    for(int idx = 0; idx < len - 1; ++idx)
    {
        flag = false;//每趟初始设置为false

        for(int j = 0; j < len - 1 - idx; ++j)
        {
            if(nums[j] > nums[j + 1])
            {
                swap(nums[j], nums[j + 1]);
                flag = true;//表示有交换
            }
        }

        if(!flag)
        //一趟中没有元素交换，提前退出
        {
            break;
        }
    }
}
==============================================
void SelectSort(vector<int>& nums)
{
    int len = nums.size();
    int minindex = 0;

    for(int idx = 0; idx < len; ++idx)
    {
        minindex = idx;
        for(int j = idx + 1; j < len; ++j)
        {
            if(nums[j] < nums[minindex])
            {
                minindex = j;//记录最小元素的下标
            }
        }
        //交换两元素的位置，将最小的元素放到已有序对列的末尾
        swap(nums[idx], nums[minindex]);
    }
}

void Select(vector<int> &nums)
{
   int len = nums.size();
   for (int idx = len - 1; idx >= 0; --idx) {
       int maxIndex = idx;
       for (int j = idx - 1; j >= 0; --j) {
           if (nums[j] > nums[maxIndex]) {
               maxIndex = j;//记录最大元素的下标
           }
       }
       swap(nums[idx], nums[maxIndex]);
   } 
}
============================================
void Insertsort(vector<int>& nums)
{
    int len = nums.size();

    for (int idx = 1; idx < len; ++idx) {
        if (nums[idx] < nums[idx - 1]) {
            //待插入的值小于有序序列中最后一个元素，需要将其前方比它大的元素后移

            int j = idx - 1;//j为需要后移元素的下标
            int insertNum = nums[idx];//保存哨兵

            while(j >= 0 && insertNum < nums[j]) {//后移操作
                //将j下标的元素后移，j指向前一个元素下标
                nums[j + 1] = nums[j];
                --j;
            }

            nums[j + 1] = insertNum;//插入对应空位置
        }
    }
}
```

### 2、希尔排序(On,O太复杂;O1)

- 算法思想：
  - 采用插入排序的方法，先让数组中任意间隔为 h 的元素有序，刚开始 h 的大小可以是 h = n / 2,接着让 h = n / 4，让 h 一直缩小，当 h = 1 时，也就是此时数组中任意间隔为1的元素有序，此时的数组就是有序的了。

```c++
void ShellSortCore(vector<int>& nums, int gap, int idx)
//插入排序核心思想实现
{
    int insertNum = nums[idx];//保存待插入的值
    int j = idx - gap;//从前面一个值开始后移

    while(j >= 0 && insertNum < nums[j]) {
        nums[j + gap] = nums[j];
        j -= gap;
    }

    nums[j + gap] = insertNum;//插入到空位置
}

void ShellSort(vector<int>& nums)
{
    int len = nums.size();

    for (int gap = len / 2; gap > 0; gap /= 2) {
        //将数组进行分组，间隔为gap，循环不断缩小gap直到为1
        for (int idx = gap; idx < len; ++idx) {
            //每组又进行插入排序，形成局部有序
            ShellSortCore(nums, gap, idx);
        }
    }
}
```

### 3、快速排序(Onlogn,On^2[最差];Ologn)【⭐】

- **算法思想**

  1、选取最后一个数为基准

  2、将比基准小的数交换到前面，比基准大的数交换到后面

  3、对左右区间重复第二步，直到各区间只有一个数

```c++
int Partition(vector<int>& nums, int start, int end)
{
    int endPos = start - 1;//定义一开始中轴元素的插入位置

    for (int idx = start; idx < end; ++idx) {
        if (nums[idx] < nums[end]) {
            //小于中轴元素的值就++endPos
            ++endPos;
            //此时endPos指向待交换的元素，左边全部的值小于中轴元素
            if(idx != endPos) {
            //不相等的是因为++idx过程中有大于end的值而endPos没有++
            //然后出现了小于end的值在endPos右方
                swap(nums[idx], nums[endPos]);
                //交换双方的值，endPos指向大于end的值，idx指向小于end的值
            }
        }
    }
    ++endPos;//endPos指向待插入的位置
    swap(nums[endPos], nums[end]);

    return endPos;//返回中轴元素的下标，用于进一步的递归
}

void QuickSort(vector<int>& nums, int start, int end)
{
    if (start == end) {//递归退出条件！！！
        return;
    }

    int index = Partition(nums, start, end);//获取中轴元素下标

    //分别递归排序中轴元素左右
    if (index > start) {
        QuickSort(nums, start, index - 1);
    }
    if (index < end) {
        QuickSort(nums, index + 1, end);
    }
}
```

### 4、堆排序(Onlogn;O1)【⭐】

- 算法思想
  - 将待排序序列构造成一个大顶堆，此时，整个序列的最大值就是堆顶的根节点。
  - 将其与末尾元素进行交换，此时末尾就为最大值。
  - 然后将剩余n-1个元素重新构造成一个堆，这样会得到n个元素的次小值。
  - 如此反复执行，便能得到一个有序序列了

```c++
void heapify(vector<int>& tree, int unsortTreeLen, int parent) 
{//对有一定顺序的的堆从上到下的大根堆化
    if (parent >= unsortTreeLen) {//递归出口
        return;
    }
    int leftChild = 2 * parent + 1;
    int rightChild = 2 * parent + 2;
    int max = parent;
    if (leftChild < unsortTreeLen && tree[leftChild] > tree[max]) {
        max = leftChild;
    }
    if (rightChild < unsortTreeLen && tree[rightChild] > tree[max]) {
        max = rightChild;
    }
    if (max != parent) {
        swap(tree[max], tree[parent]);
        heapify(tree, unsortTreeLen, max);
    }
}

void buildHeap(vector<int>& tree) 
{//第一次建立大根堆
    int lastNode = tree.size() - 1;
    int parent = (lastNode - 1) / 2;
    for (int idx = parent; idx >= 0; --idx) {
        //从最后一个结点的父节点开始往下的大根堆化，完成后接着上一个结点的大根堆化
        heapify(tree, tree.size(), idx);
    }
}

void heapSort(vector<int>& tree) 
{
    buildHeap(tree);//建大根堆
    for (int idx = tree.size() - 1; idx >= 0; --idx) {
        //头与尾交换tree.size()-1次
        swap(tree[idx], tree[0]);
        //在进行从上到下的大根堆化
        heapify(tree, idx, 0);
    }
}
```

### 5、归并排序(Onlogn;On)【稳】【⭐】

- **算法思想**

  1、把长度为n的输入序列分成两个长度为n/2的子序列；

  2、对这两个子序列分别采用归并排序；

  3、 将两个排序好的子序列合并成一个最终的排序序列。

```c++
void MergeSort(vector<int>& nums, vector<int>& tmp, int start, int end)
//需要 一个额外的空间存储排序后的值
{
    // if (start == end) {
    if (start >= end) {//递归退出条件
        return;
    }

    int mid = start + (end - start) / 2;
    //求元素个数中位数，将其分成两半分别递归进行排序
    int low1 = start, low2 = mid + 1;
    int high1= mid, high2 = end;

    MergeSort(nums, tmp, low1, high1);
    MergeSort(nums, tmp, low2, high2);
    //排序完成后，有两个有序的子序列，将其进行有序合并

    int index = start;
    //将start-end范围内的值进行排序，保存到tmp数组中
    while (low1 <= high1 && low2 <= high2) {
        //当有一个序列已经为空时退出
        tmp[index++] = nums[low1] < nums[low2] ? nums[low1++] : nums[low2++];
    }

    while (low1 <= high1) {
        //将剩下的另一个序列直接拷贝到tmp数组中
        tmp[index++] = nums[low1++];
    }

    while (low2 <= high2) {
        //将剩下的另一个序列直接拷贝到tmp数组中
        tmp[index++] = nums[low2++];
    }

    for (index = start; index <= end; ++index) {
        //将tmp数组拷贝到原数组中
        nums[index] = tmp[index];
    }
}

void MergeSort2(vector<int>& nums, vector<int>& tmp, int start, int end)
{
    if (start == end) {
        return;
    }

    int mid = start + ((end - start) >> 1);
    int low1 = start, low2 = mid + 1;
    int high1 = mid, high2 = end;

    MergeSort2(tmp, nums, low1, high1);//减少了tmp向nums的赋值部分
    //两个值放反了就是上面第一种需要在最后把tmp赋值到nums的方法
    MergeSort2(tmp, nums, low2, high2);

    int index = start;
    while (low1 <= high1 && low2 <= high2) {
        tmp[index++] = nums[low1] < nums[low2] ? nums[low1++] : nums[low2++];
    }

    while (low1 <= high1) {
        tmp[index++] = nums[low1++];
    }
    
    while (low2 <= high2) {
        tmp[index++] = nums[low2++];
    }
}
```

### 6、应用场景
（1）当**数据规模较小**时候，可以使用简单的**直接插入排序或者直接选择排序**。

（2）当文件的初态已经**基本有序**，可以用**直接插入排序和冒泡排序**。

（3）当数**据规模较大**时，应用速度最快的排序算法，可以考虑使用**快速排序**。当记录随机分布的时候，快速排序平均时间最短，但是出现最坏的情况，这个时候的时间复杂度是O(n^2)，且递归深度为n,所需的占空间为O(n)。

（4）堆排序不会出快排那样最坏情况，且**堆排序**所需的**辅助空间比快排要少**，但是这两种算法都不是稳定的，要求排序时是**稳定的，可以考虑用归并排序**。

（5）**归并排序可以用于内部排序，也可以使用于外部排序**。在外部排序时，通常**采用多路归并**，并且通过解决长顺串的合并，缠上长的初始串，提高主机与外设并行能力等，**以减少访问外存额外次数，提高外排的效率**。

### 7、C库函数——qsort（应用事例）【吹水】

- 对于小规模数据排序，几K的数据，会优先使用归并排序，用空间换时间
- 当数据量很大时，使用快速排序
  - 选择分区点：三数取中法
  - 自己实现一个栈来模拟递归调用解决栈溢出的问题
  - 当排序区间中元素个数小于或等于4时，会选择（哨兵方式）的插入排序

### 8、线性排序——基数排序、桶排序、计数排序【了解，吹水】

- 基数排序
  - **算法思想**：
    1. 取得数组中的最大数，并取得位数；
    2. arr为原始数组，从最低位开始取每个位组成radix数组；
    3. 对radix进行计数排序（利用计数排序适用于小范围数的特点）
  - 应用场景：
    - 身份证，手机号排序

- 桶排序
  - **算法思想**：
    1. 设置一个定量的数组当作空桶子。
    2. 寻访序列，并且把项目一个一个放到对应的桶子去。
    3. 对每个不是空的桶子进行排序。
    4. 从不是空的桶子里把项目再放回原来的序列中。
  - 应用场景：
    - 外部排序，当数据量过大时，无法一次性加载到内存中，使用桶排序
- 计数排序
  - **算法思想**：
    1. 找出待排序的数组中最大和最小的元素；
    2. 统计数组中每个值为 i 的元素出现的次数，存入数组 C 的第 i 项；
    3. 对所有的计数累加（从 C 中的第一个元素开始，每一项和前一项相加）；
    4. 向填充目标数组：将每个元素 i 放在新数组的第 C[i] 项，每放一个元素就将 C[i] 减去 1；
  - 应用场景：
    - 高考的查分系统，在较小的数据范围内，根据总分数按一分划分每一个桶，桶内不需要进行排序，然后依次输出到一个数组中，实现对几十万考生的排序
    - 年龄排序、考生排序

# 高频算法题

## - 设计模式

### 1、线程安全的单例模式【⭐】

```c++
#include <iostream>

using std::cout;
using std::endl;

//1、单例模式的自动释放：内部类 + 静态数据成员 
class Singleton
{
public:
    static Singleton *getInstance()
    {
        if (nullptr == _pInstance) {
            _pInstance = new Singleton();
        }

        return _pInstance;
    }

private:
    Singleton()
    {
        cout << "Singleton()" << endl;
    }

    ~Singleton()
    {
        cout << "~Singleton()" << endl;
    }

private:
    class AutoRelease
    {
    public:
        AutoRelease()
        {
            cout << "AutoRelease()" << endl;
        }

        ~AutoRelease()
        {
            cout << "~AutoRelease()" << endl;
            if (_pInstance) {
                delete _pInstance;
                _pInstance = nullptr;
            }
        }
    };

private:
    static Singleton *_pInstance;
    static AutoRelease _ar;
};

Singleton *Singleton::_pInstance = getInstance();//（饿汉模式）不会有线程安全问题
// Singleton *Singleton::_pInstance = nullptr;//（懒汉模式）会有线程安全问题
Singleton::AutoRelease Singleton::_ar;//单例模式自动释放实现
```



## - 数组

### 1、两个有序数组合并

```c++
class Solution
{
public:
    void merge(vector<int> &nums1, int m, vector<int> &nums2, int n)
    {
        _tmp.reserve(nums1.size());
        int i = 0, j = 0;
        while (i < m && j < n) {
            if (nums1[i] < nums2[j]) {
                _tmp.emplace_back(nums1[i]);
                ++i;
            }
            else {
                _tmp.emplace_back(nums2[j]);
                ++j;
            }
        }

        while (i < m) {
            _tmp.emplace_back(nums1[i]);
            ++i;
        }

        while (j < n) {
            _tmp.emplace_back(nums2[j]);
            ++j;
        }

        nums1.clear();
        for (auto elem : _tmp) {
            nums1.emplace_back(elem);
        }
    }

private:
    vector<int> _tmp;
};
```

### 2、奇偶数组（奇数值前偶数值后）【⭐】

```c++
vector<int> exchange(vector<int>& nums) 
    {
        if(nums.empty())
        {
            cerr << "vector is empty. " << endl;
            return nums;
        }

        auto iterBegin = nums.begin();
        auto iterEnd = nums.end() - 1;
        
        while(iterBegin < iterEnd)
        {
            //将迭代器向后移动，直到它指向偶数
            //2 => 0010 & 0x1 => 0001 ===> 0000 代表为偶数，反之为奇数  
            while(iterBegin < iterEnd && (*iterBegin & 0x1) != 0)
            {
                ++iterBegin;
            }

            //将迭代器向前移动，直到它指向奇数
            while(iterBegin < iterEnd && (*iterEnd & 0x1) == 0)
            {
                --iterEnd;
            }

            //交换位置
            if(iterBegin < iterEnd)
            {
                int temp = *iterBegin;
                *iterBegin = *iterEnd;
                *iterEnd = temp;
            }
        }

        return nums;
    }
==>该题可以将判断奇偶进行解藕，设计成一个函数isEven（），将其以函数指针的形式作为exchange的回调函数
```

### 3、两数之和 （leetcode第一题）（借助哈希表）【⭐】

```c++
class Solution
{
public:
    vector<int> twoSum(vector<int> &nums, int target)
    {
        for (int i = 0; i < nums.size(); ++i) {
            auto it = _hashTable.find(target - nums[i]);//在哈希表中找另一个数
            if (it != _hashTable.end()) {
                return {it->second, i};
            }
            _hashTable[nums[i]] = i;//记录此数及下标
        }
        return {};
    }

private:
    unordered_map<int, int> _hashTable;//保存数组中数值及下标
};
```

### 4、数组中超一半的数字 【⭐】

```c++
class Solution {//方法一 Partition思想
public:
    int majorityElement(vector<int>& nums) 
    {
        int length = nums.size();
        int middle = length >> 1;//除2
        int start = 0;
        int end = length - 1;

        int index = Partition(nums, start, end);

        while(index != middle)
        {
            if(index > middle)
            //新范围[start,index - 1]
            {
                end = index - 1;
                index = Partition(nums, start, end);
            }
            else
            //新范围[index + 1, end]
            {
                start = index + 1;
                index = Partition(nums, start, end);
            }
        }

        return nums[index];
    }

private:
    int Partition(vector<int>& nums, int start, int end)
    {
        if(nums.empty())
        {
            cerr << "nums is empty!" << endl;
        }

        //任意选取一个元素与最后的元素交换位置..(待实现)

        //选择最后一个元素为分割点进行
        // int length = nums.size();
        int endpos = start - 1;

        for(int idx = start; idx < end; ++idx)
        {
            if(nums[idx] < nums[end])
            {
                ++endpos;
                if(endpos != idx)
                {
                    swap(&nums[endpos], &nums[idx]);
                    // cout << nums[endpos] 
                    //      << nums[idx] 
                    //      << endl;
                }
            }
        }
        ++endpos;
        swap(&nums[endpos], &nums[end]);

        return endpos;
    }

    void swap(int* lhs, int* rhs)//多余，可以用STL中的swap()
    {
        int tmp = *lhs;
        *lhs = *rhs;
        *rhs = tmp;
    }
};

class Solution //方法二 更好的方法
{
public:
    int majorityElement(vector<int>& nums) 
    {
        //选取第一个数字作为开始
        int result = nums[0];
        int resultTimes = 1;

        for(int idx = 1; idx < nums.size(); ++idx)
        //遍历全部数字
        {
            if(resultTimes == 0)
            //换一个数字
            {
                result = nums[idx];
                resultTimes = 1;
            }
            else if(result == nums[idx])
            {
                ++resultTimes;
            }
            else
            {
                --resultTimes;
            }
        }

        return result;
    }
};
```

### 5、三个有序数组的交集

方法：假设当前遍历的三个数组元素分别为arr1[i],arr2[j],arr3[k],则存在以下几种可能性，
（1）如果arr[i],arr2[j],arr3[k]相等，则说明当前遍历的元素是三个数组的公共元素，可以直接打印出来，然后i,j,k加一，使三个数组同时向后移动，此时继续遍历各个数组后面的元素
（2）如果arr1[i]<arr2[j],则执行i+来继续遍历arr1后面的元素
（3）如果arr2[j]<arr3[k],j+来向后遍历
（4）如果前面条件都不满足，则说明arr1[i]>arr2[j]而且arr2[j]>arr3[k]，则k+继续遍历



## - 字符串【难题特别多】

### 1、替换空格 

```c++
class Solution {
public:
    string replaceSpace(string s) {
        int count = 0, len = s.size();
        // 统计空格数量
        for (char c : s) {
            if (c == ' ') count++;
        }
        // 修改 s 长度
        s.resize(len + 2 * count);
        // 倒序遍历修改
        for(int i = len - 1, j = s.size() - 1; i < j; i--, j--) {
            if (s[i] != ' ')
                s[j] = s[i];
            else {
                s[j - 2] = '%';
                s[j - 1] = '2';
                s[j] = '0';
                j -= 2;
            }
        }
        return s;
    }
};
```

### 2、最短单词路径（单词接龙）【难题】（借助哈希表、队列）

```c++
class Solution 
{
public:
    int ladderLength(string beginWord, 
                     string endWord, 
                     vector<string>& wordvec) 
    {
        // 将vector转成unordered_set，提高查询速度
        unordered_set<string> wordList(wordvec.begin(), wordvec.end());

        if(wordList.find(endWord) == wordList.end())
        //最终的结点不在单词列表中
        {
            return 0;
        }

        //使用哈希表map来记录<单词-到这个单词的路径长度>
        //并在广度搜索中避免进入死循环
        unordered_map<string, int> visitedMap;
        //用于广度搜索，从一个点发散到与该点的邻接点
        queue<string> que;

        que.push(beginWord);
        visitedMap.insert({beginWord, 1});//初始化开始结点与路径长度

        while(!que.empty())
        {
            string word = que.front();//获取队列头节点
            que.pop();//出队

            int pathLeg = visitedMap[word];//获取word的路径长度
            for(size_t i = 0; i < word.size(); ++i)
            {
                string newWord = word;//用于替换字母，每次替换一个位置
                for(int j = 0; j < 26; ++j)
                {
                    newWord[i] = j + 'a';//变换单词此位置的字母形式

                    if(newWord == endWord)
                    {
                        return pathLeg + 1;
                    }

                    if(wordList.find(newWord) != wordList.end()
                        && visitedMap.find(newWord) == visitedMap.end())
                    //找到邻接结点，并且未被访问
                    {
                        //添加访问信息
                        visitedMap.insert({newWord, pathLeg + 1});
                        que.push(newWord);//结点入队，继续广度搜索
                    }
                }

            }
        }
        return 0;
    }
};
```

### 3、字符串全排列（回溯算法）【好题、难题】

```c++
class Solution
{
public:
    vector<string> permutation(string s)
    {
        if (0 == s.size()) return vector<string>();
        permutationCore(s, 0, s.size() - 1);
        sort(_result.begin(), _result.end());//将字符串按字典序排序
        return _result;
    }

private:
    void permutationCore(string &s, int start, int end)
    {
        if (start == end) {//将排列加入到vector中
            _result.push_back(s);
            return;
        }
        unordered_map<int, int> visited;         //防止含有重复的字符时的重复排列
        for (int idx = start; idx <= end; ++idx) {//回溯法
            if (visited[s[idx]] == 1) {
                continue;
            }
            swap(s[idx], s[start]);
            //交换后，对start后的字符串进行排列
            permutationCore(s, start + 1, end);
            //排列完成后，回归到原来的交换前的状态
            swap(s[idx], s[start]);
            visited[s[idx]] = 1;
        }
    }

private:
    vector<string> _result;//排列
};
```

### 4、最短编辑距离（关键字查询：字符串相似度）【难题】【⭐】

```c++
class Solution {
public:
    int minDistance(string word1, string word2) {
        int n = word1.size();
        int m = word2.size();

        if (0 == n * m) {//有一个字符串为空串
            return n + m;
        }

        //DP数组
        int arry[n + 1][m + 1];

        for (int i = 0; i < n + 1; ++i) {
            arry[i][0] = i;
        }

        for (int j = 0; j < m + 1; ++j) {
            arry[0][j] = j;
        }

        //计算所有的DP值
        for (int i = 1; i < n + 1; ++i) {
            for (int j = 1; j < m + 1; ++j) {
                int left = arry[i - 1][j] + 1;//执行删除操作
                int down = arry[i][j - 1] + 1;//执行插入操作
                int left_down = arry[i - 1][j - 1];//执行替换操作
                if (word1[i - 1] != word2[j - 1]) {
                    left_down += 1;
                }
                arry[i][j] = min(left, min(down, left_down));
            }
        }
        return arry[n][m];
    }
};
```

### 5、两个字符串，统计某个字符串的每一个字符出现在另一个的下标

### 6、括号匹配、正则表达式匹配、字符串中的数字



## - 链表

### 1、链表反转【⭐】

```c++
ListNode* reverseList(ListNode* head) {
//非递归
//三指针，pCur,pPre,pNext => 防断链
        ListNode* pReverseListHead = nullptr;
        ListNode* pCur = head;
        ListNode* pPre = nullptr;

        while (pCur != nullptr) {
            ListNode* pNext = pCur->next;

            if (pNext == nullptr) {
                pReverseListHead = pCur;
            }

            pCur->next = pPre;
            pPre = pCur;
            pCur = pNext;
        }

        return pReverseListHead;
    }
```

### 2、两个有序链表合并【⭐】

```c++
ListNode *mergeTwoLists(ListNode *l1, ListNode *l2){
    //非递归
        if (l1 == nullptr) return l2;
        if (l2 == nullptr) return l1;

        ListNode head(0);
        ListNode *pNode = &head;

        // ListNode *pHead = nullptr;
        while (l1 != nullptr && l2 != nullptr) {
            if (l1->val < l2->val) {
                pNode->next = l1;
                l1 = l1->next;
            }
            else
            {
                pNode->next = l2;
                l2 = l2->next;
            }
            pNode = pNode->next;
        }

        if (l1 != nullptr) {
            pNode->next = l1;
        }

        if (l2 != nullptr) {
            pNode->next = l2;
        }

        return head.next;
    }
```

### 3、奇偶链表（奇数位置前偶数位置后）、重排链表（找中点，分开两段，将后半段逆转，然后插入到前半段每缝隙）【⭐】

```c++
ListNode *oddEvenList(ListNode *head)
    {
        if (head == nullptr) {
            return head;
        }

        ListNode *p = head;
        ListNode *q = head->next;
        ListNode *evenHead = q;//保存偶数节点头位置
        while (q != nullptr && q->next != nullptr) {
            p->next = p->next->next;
            p = p->next;
            q->next = q->next->next;
            q = q->next;
        }

        p->next = evenHead;

        return head;
    }
=============================================
class Solution {
public:
    void reorderList(ListNode *head)
    {
        if (head == nullptr) {
            return;
        }

        ListNode *mid = midNode(head);//获取中间节点位置

        ListNode *needReverse = mid->next;
        mid->next = nullptr;//断开成两条链
        needReverse =  reverseList(needReverse);//对后面的链进行反转

        mergeList(head, needReverse);//将两条链合并
    }

private:
    ListNode *midNode(ListNode *head)
    {
        ListNode *slow = head;
        ListNode *fast = head;
        while (fast != nullptr && fast->next != nullptr) {
            slow = slow->next;
            fast = fast->next->next;
        }

        return slow;
    }

    ListNode *reverseList(ListNode *head)
    {
        ListNode* pReverseListHead = nullptr;
        ListNode* pCur = head;
        ListNode* pPre = nullptr;

        ListNode *pNext = nullptr;
        while (pCur != nullptr) {
            //ListNode* pNext = pCur->next;
            pNext = pCur->next;
            
            if (pNext == nullptr) {
                pReverseListHead = pCur;
            }

            pCur->next = pPre;
            pPre = pCur;
            pCur = pNext;
        }

        return pReverseListHead;
    }

    void mergeList(ListNode *l1, ListNode *l2)
    {
        ListNode *tmp1 = nullptr;
        ListNode *tmp2 = nullptr;
        while (l1 != nullptr && l2 != nullptr) {
            tmp1 = l1->next;//保存后方位置
            tmp2 = l2->next;

            l1->next = l2;//先l1连l2
            l1 = tmp1;

            l2->next = l1;
            l2 = tmp2;
        }
    }
};
```

### 5、链表判断有环 或 相交【⭐】

```c++
//O（1）的内存解决 => 双指针快慢法
    bool hasCycle(ListNode *head)
    {
        if (head == nullptr || head->next == nullptr) {
            return false;
        }

        ListNode *slow = head;
        ListNode *fast = head->next;

        while (slow != fast) {
            if (fast == nullptr || fast->next == nullptr) {
                return false;
            }

            slow = slow->next;
            fast = fast->next->next;
        }
        return true;
    }
=======================================
ListNode *getIntersectionNode(ListNode *headA, ListNode *headB)
    {
        if(headA == nullptr || headB == nullptr) return nullptr;
        ListNode *pA = headA;
        ListNode *pB = headB;
        while (pA != pB) {//双指针法 => 遍历两个链表找相交
            pA = pA == nullptr ? headB : pA->next;
            pB = pB == nullptr ? headA : pB->next;
        }
        return pA;
    }
```

### 6、链表的倒数第K个节点（注意代码的鲁棒性）

### 7、STL库中list的应用 = 》LRU缓存的设计【⭐】（借助哈希表加快查找）

```C++
class LRUCache {
public:
    LRUCache(int capacity) 
    : _capacity(capacity)
    {}

    int get(int key)
    {
        auto it = _table.find(key);
        if (it != _table.end()) {
            _lru.splice(_lru.begin(), _lru, it->second);//it->second => 指向链表节点的指针
            //转移it所指向的元素到_lru，放在_lru.begin()之前
            return it->second->second;//value 
        }
        return -1;
    }

    void put(int key, int value)
    {
        auto it = _table.find(key);
        if (it != _table.end()) {
            _lru.splice(_lru.begin(), _lru, it->second);//插到链表头
            it->second->second = value;
        }
        else {
            if (_capacity == _table.size()) {
                // auto it = _lru.end();
                // _table.erase(it->first);

                _table.erase(_lru.back().first);

                _lru.pop_back();
            }
            _lru.emplace_front(key, value);//插入到链表头
            // _lru.push_front({key, value});
            //emplace_back 避免了 push_back 的额外复制或移动操作

            _table[key] = _lru.begin();//更新hashTable
            // _table.insert({key, _lru.begin()});
        }
    }

private:
    int _capacity;
    list<pair<int, int>> _lru;
    unordered_map<int, list<pair<int, int>>::iterator> _table;
    //map 中保存的是 <key, 链表节点的指针>，这样查找的时候就不用需要去遍历链表了，使用 unordered_map 就能很快找到链表节点指针。
};

//采用链表结构体
class LRUCache2
{
public:
    LRUCache2(int capacity)
        : _capacity(capacity)
    {
    }
    
	int get(int key) 
    //查找key，并返回value值
    {
        auto umit = _cache.find(key);
        if(umit == _cache.end())
        {
            return -1;
        }
        else
        //存在就更新链表中的该key的结点，将其放入链表头，表示最近访问过
        {
            _listNode.splice(_listNode.begin(), _listNode, umit->second);
            return umit->second->value;
        }
    }
    
    void put(int key, int value) 
    //插入key-value值
    {
        // unordered_map<int, list<CacheNode>::iterator>::iterator umit;
        auto umit = _cache.find(key);
        if(umit != _cache.end())
        //如果该key已经存在，更新value，并将其放在链表头，头部结点表示最近访问
        {
            umit->second->value = value;
            _listNode.splice(_listNode.begin(), _listNode, umit->second);
        }
        else
        {
            if(_capacity == _cache.size())
            //cache已满，删除链表尾结点，尾部表示上次被访问距离现在的时间最长
            {
                auto &delNode = _listNode.back();//找到尾结点CacheNode
                _cache.erase(delNode.key);//从uo_map中删除
                //uo_map的erase用法之一 => size_type erase( const key_type& key );

                _listNode.pop_back();//从list中删除
            }
            //在链表头插入，并插入到uo_map中
            _listNode.push_front(CacheNode(key, value));
            _cache.insert(std::make_pair(key, _listNode.begin()));
            // _cache[key] = _listNode.begin();
        }
    }

private:
    struct CacheNode 
    //链表结点，存放key-value
    {
        int key;
        int value;
        CacheNode(int k, int v)
            : key(k), value(v)
        {}
    };

private:
    int _capacity;
    list<CacheNode> _listNode;
    //节点放在list链表中
    unordered_map<int, list<CacheNode>::iterator> _cache;
    //储存key值以及在链表中的位置，哈希表，实现O(1)时间复杂度找到结点位置
};
```



## - 二叉树

### 1、二叉树搜索树（排序树）前中后遍历（递归&迭代）层序遍历（借助队列）【⭐】

```c++
//前序遍历
class Solution
{
public:
    vector<int> preorderTraversal(TreeNode *root)
    {
        //根左右，递归
        if (root == nullptr) return {};
        _ret.emplace_back(root->val);
        preorderTraversal(root->left);
        preorderTraversal(root->right);
        return _ret;
    }

    vector<int> preorderTraversal2(TreeNode *root)
    {
        //迭代
        if (root == nullptr) return {};
        TreeNode *pNode = root;
        while (pNode != nullptr || !_stk.empty()) {
            while (pNode != nullptr) {//根左
                _ret.emplace_back(pNode->val);
                _stk.emplace(pNode);//保存根节点，用于返回到根节点遍历右子树
                pNode = pNode->left;
            }
            pNode = _stk.top();//获取根节点
            _stk.pop(); 
            pNode = pNode->right;//右
        }
        return _ret;
    }

private:
    vector<int> _ret;
    stack<TreeNode*> _stk;
};

//中序遍历
class Solution2
{
public:
    vector<int> inorderTraversal(TreeNode *root)
    {
        //递归，左根右
        if (root == nullptr) return {};
        inorderTraversal(root->left);
        _ret.emplace_back(root->val);
        inorderTraversal(root->right);
        return _ret;
    }

    vector<int> inorderTraversal2(TreeNode *root)
    {
        //迭代
        if (root == nullptr) return {};
        TreeNode *pNode = root;
        while (pNode != nullptr || !_stk.empty()) {
            while (pNode != nullptr) {//左
                _stk.emplace(pNode);
                pNode = pNode->left;
            }
            pNode = _stk.top();
            _stk.pop();
            _ret.emplace_back(pNode->val);//根
            pNode = pNode->right;//右
        }
        return _ret;
    }

private:
    vector<int> _ret;
    stack<TreeNode*> _stk; 
};

//后序遍历
class Solution3
{
public:
    vector<int> postorderTraversal(TreeNode *root)
    {
        //递归，左右根
        if (root == nullptr) return {};
        postorderTraversal(root->left);
        postorderTraversal(root->right);
        _ret.emplace_back(root->val);
        return _ret;
    }

    vector<int> postorderTraversal2(TreeNode *root)
    {
        //迭代
        if (root == nullptr) return {};
        TreeNode *pNode = root;
        TreeNode *pVisitedNode = nullptr;
        while (pNode != nullptr || !_stk.empty()) {
            while (pNode != nullptr) {
                _stk.emplace(pNode);
                pNode = pNode->left;
            }
            pNode = _stk.top();//获取根节点位置
            if (pNode->right == nullptr 
            || pVisitedNode == pNode->right) {
                //根节点右孩子遍历完
                _ret.emplace_back(pNode->val);//根节点插入到序列中
                _stk.pop();
                pVisitedNode = pNode;//设置下一次节点访问不需要访问此根节点
                pNode = nullptr;//置空后，获取栈顶节点
            }
            else {
                pNode = pNode->right;//还没遍历右孩子
            }
        }
        return _ret;
    }

private:
    vector<int> _ret;
    stack<TreeNode*> _stk;
};

//层序遍历
class Solution4
{
public:
    vector<vector<int>> levelOrder(TreeNode *root)
    {
        if (root == nullptr) return {};
        _que.push(root);//放入根节点
        int currentLevelSize = 0;//当前层的节点个数
        while (!_que.empty()) {//循环全部节点
            currentLevelSize = _que.size();
            _ret.emplace_back(vector<int>());//每层用一个数组保存
            for (int idx = 1; idx <= currentLevelSize; ++idx) {
                auto pNode = _que.front();//获取头节点，并出队
                _que.pop();
                _ret.back().emplace_back(pNode->val);//在创建的新数组中插入
                if (pNode->left) _que.push(pNode->left);//左子树入队
                if (pNode->right) _que.push(pNode->right);//右子树入队
            }
        }
        return _ret;
    }

private:
    vector<vector<int>> _ret;
    queue<TreeNode*> _que;
};
```

### 2、二叉树镜像反转

### 3、求二叉树的节点个数

```c++
class Solution {
public:
    int countNodes(TreeNode* root) {
        if(root == nullptr) return 0;
        int left_cnt = countNodes(root->left);
        int right_cnt = countNodes(root->right);
        return 1 + (left_cnt + right_cnt);
    }
};
```

### 4、增删查改

### 5、重建二叉树【⭐】

```c++
struct TreeNode
{
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode(int x) : val(x), left(NULL), right(NULL) {}
};

class Solution {
public:
    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {
        unordered_map<int, int>hashmap;//使用hash表加速检索中序遍历序列中元素的下标
        for (int idx = 0; idx < inorder.size(); ++idx) {
            hashmap.insert({inorder[idx], idx});//将中序序列{元素，数组下标}加入到hashTable
        }
        return buildTreeCore(hashmap, preorder, 0, 0, inorder.size() - 1);//返回指向root节点指针
    }
private:
    TreeNode* buildTreeCore(unordered_map<int, int>& hashmap, vector<int>& pre, int low1, int low2, int high2) {
        //中序hash表(获取元素值在中序数组的下标)，前序数组(获取元素值)，前序root(用于建立节点)，中序strat和end(用于左右子树递归)

        // if (low1 == pre.size() || low2 > high2) {//递归退出条件
        if (low2 > high2) {//递归退出条件
            return nullptr;
        }
        TreeNode* root = new TreeNode(pre[low1]);//递归new每个节点用于返回其指针，接着上一层节点与此节点相连
        int index = hashmap[pre[low1]];//找此节点在中序的下标
        //按此节点在中序的下标位置分开两半，不断左右递归建立二叉树
        root->left = buildTreeCore(hashmap, pre, low1 + 1, low2, index - 1);
        root->right = buildTreeCore(hashmap, pre, (low1 + 1) + (index - low2), index + 1, high2);

        return root;
    }
};
```



## - 栈

### 1、最大、最小栈的设计

```c++
class MinStack {
public:
    /** initialize your data structure here. */
    MinStack()
    {}

    void push(int x)
    {
        _data.push(x);

        if (_min.size() == 0 || _min.top() > x) {//辅助栈为空或x比辅助栈的栈顶元素更大
            _min.push(x);
        }
        else {
            _min.push(_min.top());
        }
    }

    void pop()
    {
        if (_data.size() > 0 && _min.size() > 0) {
            _data.pop();
            _min.pop();
        }
        else {
            cerr << "stack is empty" << endl;
        }
    }

    int top()
    {
        return _data.top();
    }

    int min()
    {
        return _min.top();
    }

private:
    stack<int> _data;//数据栈
    stack<int> _min;//辅助栈
};
```



## - 数学

### 1、一定范围内的质数（素数）【⭐】

```c++
class Solution
{
public:
    int countPrimes(int n)//计算n以内质数的数量
    {
        // int cnt = 0;
        for (int i = 2; i < n; ++i) {
            print(i);
            // cnt += isPrimes(i);
        }
        // return cnt;
    }

    void print(int i)//打印此素数
    {
        if (isPrimes(i)) {
            cout << i << "is prime" << endl;
        }
    }

private:
    bool isPrimes(int num)
    {
        for (int i = 2; i * i <= num; ++i) {
            //不难发现较小数一定落在 [2,√num] 的区间中
            //单次检查的时间复杂度从 O(n) 降低至了 O(√n)
            if (num % i == 0) {
                return false;
            }
        }
        return true;
    }
};
```



## - 二分查找

### 1、丢失的数字（非有序）、0 - n-1中缺失的数字

### 2、旋转数组中的最小值（二分查找失败后变为暴力法）

```c++
class Solution
{
public:
    int minArray(vector<int> &numbers)
    {
        if (numbers.empty()) cerr << "numbers is empty" << endl;

        int index1 = 0;
        int index2 = numbers.size() - 1;
        int indexMid = index1;

        while (numbers[index1] >= numbers[index2]) {
            if ((index2 - index1) == 1) {//当前后两个指针相邻时，index2所指为最小值
                indexMid = index2;
                break;
            }
            indexMid = (index2 + index1) / 2;//中点
            //  indexMid = (index2 + index1) >> 1;//OK
            if (numbers[indexMid] == numbers[index1] 
                && numbers[indexMid] == numbers[index2]) {
                //当前后中三个数相同时无法比较，需要从头遍历找最小值
                return minInorder(numbers);
                }
            if (numbers[indexMid] >= numbers[index1]) {
                index1 = indexMid;
            }
            if (numbers[indexMid] <= numbers[index2]) {
                index2 = indexMid;
            }
        }
        return numbers[indexMid];
    }

private:
    int minInorder(vector<int> &nums)
    {
        int ret = nums[0];
        for (int idx = 1; idx < nums.size() - 1; ++idx) {
            if (nums[idx] < ret) ret = nums[idx];
        }
        return ret;
    }
};
```



## - 堆排序应用【⭐】

### 1、倒数第K大

### 2、TopK =》（其他方法：快排思想（快、但修改原数组））

### 3、最小、最大K个数

### 4、priority_queue（优先级队列）=》实现TopK最简单



## - B树、B+树：实现思想及应用场景

- **B树**

<img src="C:\Users\10690\AppData\Roaming\Typora\typora-user-images\image-20210916180409995.png" alt="image-20210916180409995" style="zoom:67%;" />

- **B+树**

<img src="C:\Users\10690\AppData\Roaming\Typora\typora-user-images\image-20210916180507330.png" alt="image-20210916180507330" style="zoom:67%;" />

- **应用场景：**

  - B树大量应用在数据库和文件系统：
    - 设计思想是，将相关数据尽量集中在一起，以便一次读取多个数据，减少硬盘操作次数。B树算法减少定位记录时所经历的中间过程，从而加快存取速度。
  - mysql使用B+树作为索引

- B+树相对B树的优点：

  ①B+树的所有Data域在叶子节点，一般来说都会进行一个优化，就是将所有的叶子节点用指针串联起来，遍历叶子节点就能获取全部数据，这样就能进行区间访问了。

  ②IO一次读数据是从磁盘上读的，磁盘容量是固定的，取数据量大小是固定的，非叶子节点不存储数据，节点小，磁盘IO次数就少。

## - 红黑树应用：实现思想及应用场景【⭐】

**红黑树概念**

面试时候现场**写红黑树代码的概率几乎为0**，但是红黑树一些**基本概念还是需要掌握**的。

1、它是**二叉排序树**（继承二叉排序树特显）：

- 若左子树不空，则左子树上所有结点的值均小于或等于它的根结点的值。
- 若右子树不空，则右子树上所有结点的值均大于或等于它的根结点的值。

- 左、右子树也分别为二叉排序树。

2、它满足如下几点要求：

- 树中所有节点**非红即黑**。

- **根节点必为黑节点**。

- **红节点的子节点必为黑**（**黑节点子节点可为黑**）。

- 从**根到NULL的任何路径上黑结点数相同**。

3、**查找时间**一定可以控制在**O(logn)**。

### 1、最小、最大K个数

### 2、epoll底层实现【⭐】

- 常用的IO多路复用方式有`select`、`poll`和`epoll`
- 区别：
  - select监控的文件描述符有限制，默认是1024个，与底层实现是位图有关；poll（使用链表的方式存储fd）与epoll（红黑树+双向链表）没有最大文件描述符限制
  - select与poll一致，是轮询+遍历集合来检查就绪文件描述符；epoll只需要检查就绪链表，不需要遍历所有的文件描述符
  - select每次都会修改监控的集合，所以每次都需要把监听的文件描述符重新加入到集合中；epoll把需要监听的文件描述符加入到红黑树时，一次注册后永久生效，并且内核会给每一个加入到红黑树上的文件描述符注册一个回调函数（作用：当文件描述符就绪时执行回调函数）-> 将其加入到双向链表中
- 效率问题：
  - epoll不一定比select效率高，一般认为在并发量低，socket的文件描述符都比较活跃的情况下，select的效率会更高
- 代码实现：
  - 使用循环（islooping标志位进行控制），一直再监听文件描述符
  - 接受对应的文件描述符，处理相应的事务

### 3、set、map等等

### 4、Linux中进程的调度



## - 哈希表应用：实现思想及应用场景【⭐】

<img src="C:\Users\10690\AppData\Roaming\Typora\typora-user-images\image-20210916173237060.png" alt="image-20210916173237060" style="zoom:67%;" />

实现原理：**hashtable**中的bucket所维护的list是其**自己定义的由hashtable_node数据结构组成的linked-list，而bucket聚合体本身使用vector进行存储**。hashtable的**迭代器只提供前进操作，不提供后退操作**

在hashtable设计**bucket的数量上，其内置了28个质数[53, 97, 193,...,429496729]**，在创建hashtable时，**会根据存入的元素个数选择大于等于元素个数的质数作为hashtable的容量（vector的长度）**，其中**每个bucket所维护的linked-list长度也等于hashtable的容量**。如果插入hashtable的元素个数**超过了bucket的容量，就要进行重建table操作，即找出下一个质数，创建新的buckets vector，重新计算元素在新hashtable的位置**。

### 1、unordered_map：底层使用hashtable

 - 哈希冲突的解决：STL中的hashtable使用的是**开链法**解决hash冲突问题

    - **线性探测**

      使用hash函数计算出的位置如果已经有元素占用了，则向后依次寻找，找到表尾则回到表头，直到找到一个空位

    - **开链**

      每个表格维护一个list，如果hash函数计算出的格子相同，则按顺序存在这个list中

    - **再散列**

      发生冲突时使用另一种hash函数再计算一个地址，直到不冲突

- 一致性哈希（吹水）
  - 一致性哈希的目的就是为了在节点数目发生改变时尽可能少的迁移数据，将所有的存储节点排列在收尾相接的Hash环上，每个key在计算Hash 后会顺时针找到临接的存储节点存放。



## - 红黑树与哈希表的比较【⭐】

- map适用于有序数据的应用场景，unordered_map适用于高效查询的应用场景



## - 递归的应用

### 1、爬楼梯

### 2、斐波那契数列

### 3、汉诺塔



## - 位运算的应用

### 1、字符串去重（Simhash算法）=> 网页去重【⭐】

- 0 & 0 = 0；1 & 0 = 0；1 & 1 = 1
- 0 | 0 = 0；1 | 0 = 1； 1 | 1 = 1；
- 0 ^ 0 = 0;  1 ^ 0 = 1;  1 ^ 1 = 0;
- 左移，右移

## - 回溯算法的应用

### 1、二维数组中找路径、运动范围

### 2、全排列、N皇后



## - 其他特殊问题

### 1、负载均衡算法

### 2、压缩算法（有损、无损）

### 3、背包问题

### 4、余弦相似度算法（网页查询：网页相似度）【⭐】

### 5、贪心算法（进阶版动态规划）



